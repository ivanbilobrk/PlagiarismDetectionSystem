1       // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
2       
3       use rusty_v8 as v8;
        |USE|USE_ITEM

4       
5       use crate::bindings;
        |USE|USE_ITEM     |

6       use crate::error::attach_handle_to_error;
        |USE|USE_ITEM                          |

7       use crate::error::generic_error;
        |USE|USE_ITEM                 |

8       use crate::error::AnyError;
        |USE|USE_ITEM            |

9       use crate::error::ErrWithV8Handle;
        |USE|USE_ITEM                   |

10      use crate::error::JsError;
        |USE|USE_ITEM           |

11      use crate::futures::FutureExt;
        |USE|USE_ITEM               |

12      use crate::module_specifier::ModuleSpecifier;
        |USE|USE_ITEM                              |

13      use crate::modules::LoadState;
        |USE|USE_ITEM               |

14      use crate::modules::ModuleId;
        |USE|USE_ITEM              |

15      use crate::modules::ModuleLoadId;
        |USE|USE_ITEM                  |

16      use crate::modules::ModuleLoader;
        |USE|USE_ITEM                  |

17      use crate::modules::ModuleSource;
        |USE|USE_ITEM                  |

18      use crate::modules::Modules;
        |USE|USE_ITEM             |

19      use crate::modules::NoopModuleLoader;
        |USE|USE_ITEM                      |

20      use crate::modules::PrepareLoadFuture;
        |USE|USE_ITEM                       |

21      use crate::modules::RecursiveModuleLoad;
        |USE|USE_ITEM                         |

22      use crate::ops::*;
        |USE            |use_item

23      use crate::shared_queue::SharedQueue;
        |USE|USE_ITEM                      |

24      use crate::shared_queue::RECOMMENDED_SIZE;
        |USE|USE_ITEM                           |

25      use crate::BufVec;
        |USE|USE_ITEM   |

26      use crate::OpState;
        |USE|USE_ITEM    |

27      use futures::channel::mpsc;
        |USE|USE_ITEM            |

28      use futures::future::poll_fn;
        |USE|USE_ITEM              |

29      use futures::stream::FuturesUnordered;
        |USE|USE_ITEM                       |

30      use futures::stream::StreamExt;
        |USE|USE_ITEM                |

31      use futures::stream::StreamFuture;
        |USE|USE_ITEM                   |

32      use futures::task::AtomicWaker;
        |USE|USE_ITEM                |

33      use futures::Future;
        |USE|USE_ITEM     |

34      use std::any::Any;
        |USE|USE_ITEM   |

35      use std::cell::Cell;
        |USE|USE_ITEM     |

36      use std::cell::RefCell;
        |USE|USE_ITEM        |

37      use std::collections::HashMap;
        |USE|USE_ITEM               |

38      use std::convert::TryFrom;
        |USE|USE_ITEM           |

39      use std::ffi::c_void;
        |USE|USE_ITEM      |

40      use std::mem::forget;
        |USE|USE_ITEM      |

41      use std::option::Option;
        |USE|USE_ITEM         |

42      use std::pin::Pin;
        |USE|USE_ITEM   |

43      use std::rc::Rc;
        |USE|USE_ITEM |

44      use std::sync::Once;
        |USE|USE_ITEM     |

45      use std::task::Context;
        |USE|USE_ITEM        |

46      use std::task::Poll;
        |USE|USE_ITEM     |

47      
48      type PendingOpFuture = Pin<Box<dyn Future<Output = (OpId, Box<[u8]>)>>>;
        |TYPE_ALIAS          |assign

49      
50      pub enum Snapshot {
            |ENUM         |enum{

51        Static(&'static [u8]),
          |ENUM_ITEM
                |tuple(
                 |t_elem      |)tuple

52        JustCreated(v8::StartupData),
          |ENUM_ITEM||tuple(
                      |T_ELEM        |)tuple

53        Boxed(Box<[u8]>),
          |ENUM_ITEM
               |tuple(
                |T_ELEM  |)tuple

54      }
        |}enum

55      
56      pub type JsErrorCreateFn = dyn Fn(JsError) -> AnyError;
            |TYPE_ALIAS          |assign

57      
58      pub type GetErrorClassFn =
            |TYPE_ALIAS          |assign

59        &'static dyn for<'e> Fn(&'e AnyError) -> &'static str;
60      
61      /// Objects that need to live as long as the isolate
62      #[derive(Default)]
        |OUTER_ATTR      |

63      struct IsolateAllocations {
        |STRUCT                   |struct{

64        near_heap_limit_callback_data:
          |FIELD                      |

65          Option<(Box<RefCell<dyn Any>>, v8::NearHeapLimitCallback)>,
66      }
        |}struct

67      
68      /// A single execution context of JavaScript. Corresponds roughly to the "Web
69      /// Worker" concept in the DOM. A JsRuntime is a Future that can be used with
70      /// an event loop (Tokio, async_std).
71      ////
72      /// The JsRuntime future completes when there is an error or when all
73      /// pending ops have completed.
74      ///
75      /// Ops are created in JavaScript by calling Deno.core.dispatch(), and in Rust
76      /// by implementing dispatcher function that takes control buffer and optional zero copy buffer
77      /// as arguments. An async Op corresponds exactly to a Promise in JavaScript.
78      pub struct JsRuntime {
            |STRUCT          |struct{

79        // This is an Option<OwnedIsolate> instead of just OwnedIsolate to workaround
80        // an safety issue with SnapshotCreator. See JsRuntime::drop.
81        v8_isolate: Option<v8::OwnedIsolate>,
          |FIELD   |

82        snapshot_creator: Option<v8::SnapshotCreator>,
          |FIELD         |

83        has_snapshotted: bool,
          |FIELD        |

84        needs_init: bool,
          |FIELD   |

85        allocations: IsolateAllocations,
          |FIELD    |

86      }
        |}struct

87      
88      struct DynImportModEvaluate {
        |STRUCT                     |struct{

89        module_id: ModuleId,
          |FIELD  |

90        promise: v8::Global<v8::Promise>,
          |FIELD|

91        module: v8::Global<v8::Module>,
          |FIELD

92      }
        |}struct

93      
94      struct ModEvaluate {
        |STRUCT            |struct{

95        promise: v8::Global<v8::Promise>,
          |FIELD|

96        sender: mpsc::Sender<Result<(), AnyError>>,
          |FIELD

97      }
        |}struct

98      
99      /// Internal state for JsRuntime which is stored in one of v8::Isolate's
100     /// embedder slots.
101     pub(crate) struct JsRuntimeState {
                   |STRUCT               |struct{

102       pub global_context: Option<v8::Global<v8::Context>>,
          |FIELD

103       pub(crate) shared_ab: Option<v8::Global<v8::SharedArrayBuffer>>,
          |FIELD
             |struct{
                   |}struct

104       pub(crate) js_recv_cb: Option<v8::Global<v8::Function>>,
          |FIELD
             |struct{
                   |}struct

105       pub(crate) js_macrotask_cb: Option<v8::Global<v8::Function>>,
          |FIELD
             |struct{
                   |}struct

106       pub(crate) pending_promise_exceptions:
          |FIELD
             |struct{
                   |}struct

107         HashMap<v8::Global<v8::Promise>, v8::Global<v8::Value>>,
108       pending_dyn_mod_evaluate: HashMap<ModuleLoadId, DynImportModEvaluate>,
          |FIELD                 |

109       pending_mod_evaluate: Option<ModEvaluate>,
          |FIELD             |

110       pub(crate) js_error_create_fn: Rc<JsErrorCreateFn>,
          |FIELD
             |struct{
                   |}struct

111       pub(crate) shared: SharedQueue,
          |FIELD
             |struct{
                   |}struct

112       pub(crate) pending_ops: FuturesUnordered<PendingOpFuture>,
          |FIELD
             |struct{
                   |}struct

113       pub(crate) pending_unref_ops: FuturesUnordered<PendingOpFuture>,
          |FIELD
             |struct{
                   |}struct

114       pub(crate) have_unpolled_ops: Cell<bool>,
          |FIELD
             |struct{
                   |}struct

115       //pub(crate) op_table: OpTable,
116       pub(crate) op_state: Rc<RefCell<OpState>>,
          |FIELD
             |struct{
                   |}struct

117       pub loader: Rc<dyn ModuleLoader>,
          |FIELD

118       pub modules: Modules,
          |FIELD

119       pub(crate) dyn_import_map:
          |FIELD
             |struct{
                   |}struct

120         HashMap<ModuleLoadId, v8::Global<v8::PromiseResolver>>,
121       preparing_dyn_imports: FuturesUnordered<Pin<Box<PrepareLoadFuture>>>,
          |FIELD              |

122       pending_dyn_imports: FuturesUnordered<StreamFuture<RecursiveModuleLoad>>,
          |FIELD            |

123       waker: AtomicWaker,
          |FIELD

124     }
        |}struct

125     
126     impl Drop for JsRuntime {
        |IMPL                   |impl{

127       fn drop(&mut self) {
          |FUNCTION
                  |PARAM  |  |func{

128         if let Some(creator) = self.snapshot_creator.take() {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG  |  |assign                     |apply
                                                                |if{

129           // TODO(ry): in rusty_v8, `SnapShotCreator::get_owned_isolate()` returns
130           // a `struct OwnedIsolate` which is not actually owned, hence the need
131           // here to leak the `OwnedIsolate` in order to avoid a double free and
132           // the segfault that it causes.
133           let v8_isolate = self.v8_isolate.take().unwrap();
              |VAR_DECL      |assign               |apply   |apply

134           forget(v8_isolate);
                    |apply
                     |ARG     |

135     
136           // TODO(ry) V8 has a strange assert which prevents a SnapshotCreator from
137           // being deallocated if it hasn't created a snapshot yet.
138           // https://github.com/v8/v8/blob/73212783fbd534fac76cc4b66aac899c13f71fc8/src/api.cc#L603
139           // If that assert is removed, this if guard could be removed.
140           // WARNING: There may be false positive LSAN errors here.
141           if self.has_snapshotted {
              |IF                     |if{

142             drop(creator);
                    |apply
                     |ARG  |

143           }
              |}if

144         }
            |}if

145       }
          |}func

146     }
        |}impl

147     
148     #[allow(clippy::missing_safety_doc)]
        |OUTER_ATTR                        |

149     pub unsafe fn v8_init() {
                   |FUNCTION    |func{

150       let platform = v8::new_default_platform().unwrap();
          |VAR_DECL    |assign                   |apply   |apply

151       v8::V8::initialize_platform(platform);
                                     |apply
                                      |ARG   |

152       v8::V8::initialize();
                            |apply

153       // TODO(ry) This makes WASM compile synchronously. Eventually we should
154       // remove this to make it work asynchronously too. But that requires getting
155       // PumpMessageLoop and RunMicrotasks setup correctly.
156       // See https://github.com/denoland/deno/issues/2544
157       let argv = vec![
          |VAR_DECL|assign
                     |MACRO()
                         |macro(){

158         "".to_string(),
159         "--wasm-test-streaming".to_string(),
160         "--no-wasm-async-compilation".to_string(),
161         "--harmony-top-level-await".to_string(),
162       ];
          |}macro()

163       v8::V8::set_flags_from_command_line(argv);
                                             |apply
                                              |ARG

164     }
        |}func

165     
166     #[derive(Default)]
        |OUTER_ATTR      |

167     pub struct RuntimeOptions {
            |STRUCT               |struct{

168       /// Allows a callback to be set whenever a V8 exception is made. This allows
169       /// the caller to wrap the JsError into an error. By default this callback
170       /// is set to `JsError::create()`.
171       pub js_error_create_fn: Option<Rc<JsErrorCreateFn>>,
          |FIELD

172     
173       /// Allows to map error type to a string "class" used to represent
174       /// error in JavaScript.
175       pub get_error_class_fn: Option<GetErrorClassFn>,
          |FIELD

176     
177       /// Implementation of `ModuleLoader` which will be
178       /// called when V8 requests to load ES modules.
179       ///
180       /// If not provided runtime will error if code being
181       /// executed tries to load modules.
182       pub module_loader: Option<Rc<dyn ModuleLoader>>,
          |FIELD

183     
184       /// V8 snapshot that should be loaded on startup.
185       ///
186       /// Currently can't be used with `will_snapshot`.
187       pub startup_snapshot: Option<Snapshot>,
          |FIELD

188     
189       /// Prepare runtime to take snapshot of loaded code.
190       ///
191       /// Currently can't be used with `startup_snapshot`.
192       pub will_snapshot: bool,
          |FIELD

193     
194       /// Isolate creation parameters.
195       pub create_params: Option<v8::CreateParams>,
          |FIELD

196     }
        |}struct

197     
198     impl JsRuntime {
        |IMPL          |impl{

199       /// Only constructor, configuration is done through `options`.
200       pub fn new(mut options: RuntimeOptions) -> Self {
              |FUNCTION
                     |PARAM                    |          |func{

201         static DENO_INIT: Once = Once::new();
            |VAR_DECL              |assign    |apply

202         DENO_INIT.call_once(|| {
                               |apply
                                |ARG|
                                |CLOSURE
                                   |closure{
                                   |return
                                   |inner{

203           unsafe { v8_init() };
                     |inner{  |apply
                                 |}inner

204         });
            |}inner
            |}closure

205     
206         let global_context;
            |VAR_DECL

207         let (mut isolate, maybe_snapshot_creator) = if options.will_snapshot {
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM              ||)tuple
                                                      |assign
                                                        |IF                      |if{

208           // TODO(ry) Support loading snapshots before snapshotting.
209           assert!(options.startup_snapshot.is_none());
              |MACRO()
                     |macro(){                          |}macro()

210           let mut creator =
              |VAR_DECL       |assign

211             v8::SnapshotCreator::new(Some(&bindings::EXTERNAL_REFERENCES));
                                        |apply
                                         |ARG                               |
                                             |apply
                                              |ARG                         |

212           let isolate = unsafe { creator.get_owned_isolate() };
              |VAR_DECL   |assign  |inner{                    |apply
                                                                 |}inner

213           let mut isolate = JsRuntime::setup_isolate(isolate);
              |VAR_DECL       |assign                   |apply
                                                         |ARG  |

214           {
              |inner{

215             let scope = &mut v8::HandleScope::new(&mut isolate);
                |VAR_DECL |assign                    |apply
                                                      |ARG       |

216             let context = bindings::initialize_context(scope);
                |VAR_DECL   |assign                       |apply
                                                           |ARG|

217             global_context = v8::Global::new(scope, context);
                               |assign          |apply
                                                 |ARG|  |ARG  |

218             creator.set_default_context(context);
                                           |apply
                                            |ARG  |

219           }
              |}inner

220           (isolate, Some(creator))
              |tuple(
               |T_ELEM  |T_ELEM
                            |apply
                             |ARG  | |)tuple

221         } else {
            |}if
              |ELSE|else{

222           let mut params = options
              |VAR_DECL      |assign

223             .create_params
224             .take()
                     |apply

225             .unwrap_or_else(v8::Isolate::create_params)
                               |apply
                                |ARG                     |

226             .external_references(&**bindings::EXTERNAL_REFERENCES);
                                    |apply
                                     |ARG                           |

227           let snapshot_loaded = if let Some(snapshot) = options.startup_snapshot {
              |VAR_DECL           |assign
                                    |IF|VAR_DECL
                                           |STRUCT()
                                                |ARG   |  |assign                    |if{

228             params = match snapshot {
                       |assign
                         |MATCH         |match{

229               Snapshot::Static(data) => params.snapshot_blob(data),
                  |CASE  |
                  |STRUCT()        |ARG                         |apply
                                                                 |ARG

230               Snapshot::JustCreated(data) => params.snapshot_blob(data),
                  |CASE  |
                  |STRUCT()             |ARG                         |apply
                                                                      |ARG

231               Snapshot::Boxed(data) => params.snapshot_blob(data),
                  |CASE  |
                  |STRUCT()       |ARG                         |apply
                                                                |ARG

232             };
                |}match

233             true
234           } else {
              |}if
                |ELSE|else{

235             false
236           };
              |else}

237     
238           let isolate = v8::Isolate::new(params);
              |VAR_DECL   |assign           |apply
                                             |ARG |

239           let mut isolate = JsRuntime::setup_isolate(isolate);
              |VAR_DECL       |assign                   |apply
                                                         |ARG  |

240           {
              |inner{

241             let scope = &mut v8::HandleScope::new(&mut isolate);
                |VAR_DECL |assign                    |apply
                                                      |ARG       |

242             let context = if snapshot_loaded {
                |VAR_DECL   |assign
                              |IF                |if{

243               v8::Context::new(scope)
                                  |apply
                                   |ARG|

244             } else {
                |}if
                  |ELSE|else{

245               // If no snapshot is provided, we initialize the context with empty
246               // main source code and source maps.
247               bindings::initialize_context(scope)
                                              |apply
                                               |ARG|

248             };
                |else}

249             global_context = v8::Global::new(scope, context);
                               |assign          |apply
                                                 |ARG|  |ARG  |

250           }
              |}inner

251           (isolate, None)
              |tuple(
               |T_ELEM  |T_ELEM
                            |)tuple

252         };
            |else}

253     
254         let loader = options
            |VAR_DECL  |assign

255           .module_loader
256           .unwrap_or_else(|| Rc::new(NoopModuleLoader));
                             |apply
                              |ARG                       |
                              |CLOSURE
                                 |CLOSURE{
                                 |RETURN|apply
                                         |ARG           ||}closure

257     
258         let js_error_create_fn = options
            |VAR_DECL              |assign

259           .js_error_create_fn
260           .unwrap_or_else(|| Rc::new(JsError::create));
                             |apply
                              |ARG                      |
                              |CLOSURE
                                 |CLOSURE{
                                 |RETURN|apply
                                         |ARG          ||}closure

261         let mut op_state = OpState::default();
            |VAR_DECL        |assign           |apply

262     
263         if let Some(get_error_class_fn) = options.get_error_class_fn {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG             |  |assign                      |if{

264           op_state.get_error_class_fn = get_error_class_fn;
                                          |assign

265         }
            |}if

266     
267         isolate.set_slot(Rc::new(RefCell::new(JsRuntimeState {
                            |apply
                             |ARG                                |
                                    |apply
                                     |ARG                        |
                                                 |apply
                                                  |ARG           |
                                                  |STRUCT()    |

268           global_context: Some(global_context),
              |ARG                               |
                                  |apply
                                   |ARG         |

269           pending_promise_exceptions: HashMap::new(),
              |ARG                                     |
                                                      |apply

270           pending_dyn_mod_evaluate: HashMap::new(),
              |ARG                                   |
                                                    |apply

271           pending_mod_evaluate: None,
              |ARG                     |

272           shared_ab: None,
              |ARG          |

273           js_recv_cb: None,
              |ARG           |

274           js_macrotask_cb: None,
              |ARG                |

275           js_error_create_fn,
              |ARG             |

276           shared: SharedQueue::new(RECOMMENDED_SIZE),
              |ARG                                     |
                                      |apply
                                       |ARG           |

277           pending_ops: FuturesUnordered::new(),
              |ARG                               |
                                                |apply

278           pending_unref_ops: FuturesUnordered::new(),
              |ARG                                     |
                                                      |apply

279           op_state: Rc::new(RefCell::new(op_state)),
              |ARG                                    |
                               |apply
                                |ARG                 |
                                            |apply
                                             |ARG   |

280           have_unpolled_ops: Cell::new(false),
              |ARG                              |
                                          |apply
                                           |ARG|

281           modules: Modules::new(),
              |ARG                  |
                                   |apply

282           loader,
              |ARG |

283           dyn_import_map: HashMap::new(),
              |ARG                         |
                                          |apply

284           preparing_dyn_imports: FuturesUnordered::new(),
              |ARG                                         |
                                                          |apply

285           pending_dyn_imports: FuturesUnordered::new(),
              |ARG                                       |
                                                        |apply

286           waker: AtomicWaker::new(),
              |ARG                    |
                                     |apply

287         })));
288     
289         Self {
            |STRUCT()

290           v8_isolate: Some(isolate),
              |ARG                    |
                              |apply
                               |ARG  |

291           snapshot_creator: maybe_snapshot_creator,
              |ARG                                   |

292           has_snapshotted: false,
              |ARG                 |

293           needs_init: true,
              |ARG           |

294           allocations: IsolateAllocations::default(),
              |ARG                                     |
                                                      |apply

295         }
296       }
          |}func

297     
298       pub fn global_context(&mut self) -> v8::Global<v8::Context> {
              |FUNCTION         |PARAM  |                             |func{

299         let state = Self::state(self.v8_isolate());
            |VAR_DECL |assign      |apply
                                    |ARG            |
                                                   |apply

300         let state = state.borrow();
            |VAR_DECL |assign       |apply

301         state.global_context.clone().unwrap()
                                      |apply   |apply

302       }
          |}func

303     
304       pub fn v8_isolate(&mut self) -> &mut v8::OwnedIsolate {
              |FUNCTION     |PARAM  |                           |func{

305         self.v8_isolate.as_mut().unwrap()
                                  |apply   |apply

306       }
          |}func

307     
308       fn setup_isolate(mut isolate: v8::OwnedIsolate) -> v8::OwnedIsolate {
          |FUNCTION        |PARAM                      |                      |func{

309         isolate.set_capture_stack_trace_for_uncaught_exceptions(true, 10);
                                                                   |apply
                                                                    |ARG  |ARG

310         isolate.set_promise_reject_callback(bindings::promise_reject_callback);
                                               |apply
                                                |ARG                            |

311         isolate.set_host_initialize_import_meta_object_callback(
                                                                   |apply

312           bindings::host_initialize_import_meta_object_callback,
              |ARG                                                |

313         );
314         isolate.set_host_import_module_dynamically_callback(
                                                               |apply

315           bindings::host_import_module_dynamically_callback,
              |ARG                                            |

316         );
317         isolate
318       }
          |}func

319     
320       pub(crate) fn state(isolate: &v8::Isolate) -> Rc<RefCell<JsRuntimeState>> {
                     |FUNCTION|PARAM              |                                 |func{

321         let s = isolate.get_slot::<Rc<RefCell<JsRuntimeState>>>().unwrap();
            |VAR_DECL
                  |assign              |T_ARG                    | |apply   |apply

322         s.clone()
                   |apply

323       }
          |}func

324     
325       /// Executes a bit of built-in JavaScript to provide Deno.sharedQueue.
326       fn shared_init(&mut self) {
          |FUNCTION      |PARAM  |  |func{

327         if self.needs_init {
            |IF                |if{

328           self.needs_init = false;
                              |assign

329           self
330             .execute("deno:core/core.js", include_str!("core.js"))
                        |apply
                         |ARG              |  |ARG                  |
                                              |MACRO()  | |macro(){ |}macro()

331             .unwrap();
                       |apply

332           self
333             .execute("deno:core/error.js", include_str!("error.js"))
                        |apply
                         |ARG               |  |ARG                   |
                                               |MACRO()  | |macro(){  |}macro()

334             .unwrap();
                       |apply

335         }
            |}if

336       }
          |}func

337     
338       /// Returns the runtime's op state, which can be used to maintain ops
339       /// and access resources between op calls.
340       pub fn op_state(&mut self) -> Rc<RefCell<OpState>> {
              |FUNCTION   |PARAM  |                          |func{

341         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

342         let state = state_rc.borrow();
            |VAR_DECL |assign          |apply

343         state.op_state.clone()
                                |apply

344       }
          |}func

345     
346       /// Executes traditional JavaScript code (traditional = not ES modules)
347       ///
348       /// The execution takes place on the current global context, so it is possible
349       /// to maintain local JS state and invoke this method multiple times.
350       ///
351       /// `AnyError` can be downcast to a type that exposes additional information
352       /// about the V8 exception. By default this type is `JsError`, however it may
353       /// be a different type if `RuntimeOptions::js_error_create_fn` has been set.
354       pub fn execute(
              |FUNCTION

355         &mut self,
            |PARAM  |

356         js_filename: &str,
            |PARAM          |

357         js_source: &str,
            |PARAM        |

358       ) -> Result<(), AnyError> {
                                    |func{

359         self.shared_init();
                            |apply

360     
361         let context = self.global_context();
            |VAR_DECL   |assign              |apply

362     
363         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

364     
365         let source = v8::String::new(scope, js_source).unwrap();
            |VAR_DECL  |assign          |apply
                                         |ARG|  |ARG    |        |apply

366         let name = v8::String::new(scope, js_filename).unwrap();
            |VAR_DECL|assign          |apply
                                       |ARG|  |ARG      |        |apply

367         let origin = bindings::script_origin(scope, name);
            |VAR_DECL  |assign                  |apply
                                                 |ARG|  |ARG

368     
369         let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|

370     
371         let script = match v8::Script::compile(tc_scope, source, Some(&origin)) {
            |VAR_DECL  |assign
                         |MATCH                   |apply
                                                   |ARG   |  |ARG |  |ARG        |
                                                                         |apply
                                                                          |ARG  |   |match{

372           Some(script) => script,
              |CASE
              |STRUCT()
                   |ARG |

373           None => {
              |CASE   |inner{

374             let exception = tc_scope.exception().unwrap();
                |VAR_DECL     |assign             |apply   |apply

375             return exception_to_err_result(tc_scope, exception, false);
                |RETURN                       |apply
                                               |ARG   |  |ARG    |  |ARG|

376           }
              |}inner

377         };
            |}match

378     
379         match script.run(tc_scope) {
            |MATCH          |apply
                             |ARG   |  |match{

380           Some(_) => Ok(()),
              |CASE
              |STRUCT()
                   |arg    |apply
                            |ARG
                            |tuple(
                             |)tuple

381           None => {
              |CASE   |inner{

382             assert!(tc_scope.has_caught());
                |MACRO()
                       |macro(){             |}macro()

383             let exception = tc_scope.exception().unwrap();
                |VAR_DECL     |assign             |apply   |apply

384             exception_to_err_result(tc_scope, exception, false)
                                       |apply
                                        |ARG   |  |ARG    |  |ARG|

385           }
              |}inner

386         }
            |}match

387       }
          |}func

388     
389       /// Takes a snapshot. The isolate should have been created with will_snapshot
390       /// set to true.
391       ///
392       /// `AnyError` can be downcast to a type that exposes additional information
393       /// about the V8 exception. By default this type is `JsError`, however it may
394       /// be a different type if `RuntimeOptions::js_error_create_fn` has been set.
395       pub fn snapshot(&mut self) -> v8::StartupData {
              |FUNCTION   |PARAM  |                     |func{

396         assert!(self.snapshot_creator.is_some());
            |MACRO()
                   |macro(){                       |}macro()

397         let state = Self::state(self.v8_isolate());
            |VAR_DECL |assign      |apply
                                    |ARG            |
                                                   |apply

398     
399         // Note: create_blob() method must not be called from within a HandleScope.
400         // TODO(piscisaureus): The rusty_v8 type system should enforce this.
401         state.borrow_mut().global_context.take();
                            |apply                |apply

402     
403         std::mem::take(&mut state.borrow_mut().modules);
                          |apply
                           |ARG                          |
                                                |apply

404     
405         let snapshot_creator = self.snapshot_creator.as_mut().unwrap();
            |VAR_DECL            |assign                       |apply   |apply

406         let snapshot = snapshot_creator
            |VAR_DECL    |assign

407           .create_blob(v8::FunctionCodeHandling::Keep)
                          |apply
                           |ARG                         |

408           .unwrap();
                     |apply

409         self.has_snapshotted = true;
                                 |assign

410     
411         snapshot
412       }
          |}func

413     
414       /// Registers an op that can be called from JavaScript.
415       ///
416       /// The _op_ mechanism allows to expose Rust functions to the JS runtime,
417       /// which can be called using the provided `name`.
418       ///
419       /// This function provides byte-level bindings. To pass data via JSON, the
420       /// following functions can be passed as an argument for `op_fn`:
421       /// * [json_op_sync()](fn.json_op_sync.html)
422       /// * [json_op_async()](fn.json_op_async.html)
423       pub fn register_op<F>(&mut self, name: &str, op_fn: F) -> OpId
              |FUNCTION      |<t>
                                |PARAM  |  |PARAM   |  |PARAM |

424       where
425         F: Fn(Rc<RefCell<OpState>>, BufVec) -> Op + 'static,
426       {
          |func{

427         Self::state(self.v8_isolate())
                       |apply
                        |ARG            |
                                       |apply

428           .borrow_mut()
                         |apply

429           .op_state
430           .borrow_mut()
                         |apply

431           .op_table
432           .register_op(name, op_fn)
                          |apply
                           |ARG  |ARG|

433       }
          |}func

434     
435       /// Registers a callback on the isolate when the memory limits are approached.
436       /// Use this to prevent V8 from crashing the process when reaching the limit.
437       ///
438       /// Calls the closure with the current heap limit and the initial heap limit.
439       /// The return value of the closure is set as the new limit.
440       pub fn add_near_heap_limit_callback<C>(&mut self, cb: C)
              |FUNCTION                       |<t>
                                                 |PARAM  |  |PARAM

441       where
442         C: FnMut(usize, usize) -> usize + 'static,
443       {
          |func{

444         let boxed_cb = Box::new(RefCell::new(cb));
            |VAR_DECL    |assign   |apply
                                    |ARG           |
                                                |apply
                                                 |ARG

445         let data = boxed_cb.as_ptr() as *mut c_void;
            |VAR_DECL|assign          |apply

446     
447         let prev = self
            |VAR_DECL|assign

448           .allocations
449           .near_heap_limit_callback_data
450           .replace((boxed_cb, near_heap_limit_callback::<C>));
                      |apply
                       |ARG                                    |
                       |tuple(
                        |T_ELEM|  |T_ELEM                |   |t_arg
                                                               |)tuple

451         if let Some((_, prev_cb)) = prev {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG       |
                        |tuple
                        |tuple(
                         |t_elem
                            |T_ELEM|)tuple
                                      |assign|if{

452           self
453             .v8_isolate()
                           |apply

454             .remove_near_heap_limit_callback(prev_cb, 0);
                                                |apply
                                                 |ARG  |  |arg

455         }
            |}if

456     
457         self
458           .v8_isolate()
                         |apply

459           .add_near_heap_limit_callback(near_heap_limit_callback::<C>, data);
                                           |apply
                                            |ARG                        |
                                                                       |t_arg
                                                                           |ARG

460       }
          |}func

461     
462       pub fn remove_near_heap_limit_callback(&mut self, heap_limit: usize) {
              |FUNCTION                          |PARAM  |  |PARAM          |  |func{

463         if let Some((_, cb)) = self.allocations.near_heap_limit_callback_data.take()
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG  |
                        |tuple
                        |tuple(
                         |t_elem
                            |T_ELEM
                              |)tuple
                                 |assign                                              |apply

464         {
            |if{

465           self
466             .v8_isolate()
                           |apply

467             .remove_near_heap_limit_callback(cb, heap_limit);
                                                |apply
                                                 |ARG|ARG     |

468         }
            |}if

469       }
          |}func

470     
471       /// Runs event loop to completion
472       ///
473       /// This future resolves when:
474       ///  - there are no more pending dynamic imports
475       ///  - there are no more pending ops
476       pub async fn run_event_loop(&mut self) -> Result<(), AnyError> {
                    |FUNCTION         |PARAM  |                          |func{

477         poll_fn(|cx| self.poll_event_loop(cx)).await
                   |apply
                    |ARG                        |
                    |closure
                     |PARAM
                         |CLOSURE{
                         |RETURN             |apply
                                              |ARG
                                                |}closure

478       }
          |}func

479     
480       /// Runs a single tick of event loop
481       pub fn poll_event_loop(
              |FUNCTION

482         &mut self,
            |PARAM  |

483         cx: &mut Context,
            |PARAM         |

484       ) -> Poll<Result<(), AnyError>> {
                                          |func{

485         self.shared_init();
                            |apply

486     
487         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

488         {
            |inner{

489           let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

490           state.waker.register(cx.waker());
                                  |apply
                                   |ARG     |
                                           |apply

491         }
            |}inner

492     
493         // Ops
494         {
            |inner{

495           let overflow_response = self.poll_pending_ops(cx);
              |VAR_DECL             |assign                |apply
                                                            |ARG

496           self.async_op_response(overflow_response)?;
                                    |apply
                                     |ARG            |

497           self.drain_macrotasks()?;
                                   |apply

498           self.check_promise_exceptions()?;
                                           |apply

499         }
            |}inner

500     
501         // Dynamic module loading - ie. modules loaded using "import()"
502         {
            |inner{

503           let poll_imports = self.prepare_dyn_imports(cx)?;
              |VAR_DECL        |assign                   |apply
                                                          |ARG

504           assert!(poll_imports.is_ready());
              |MACRO()
                     |macro(){               |}macro()

505     
506           let poll_imports = self.poll_dyn_imports(cx)?;
              |VAR_DECL        |assign                |apply
                                                       |ARG

507           assert!(poll_imports.is_ready());
              |MACRO()
                     |macro(){               |}macro()

508     
509           self.evaluate_dyn_imports();
                                       |apply

510     
511           self.check_promise_exceptions()?;
                                           |apply

512         }
            |}inner

513     
514         // Top level module
515         self.evaluate_pending_module();
                                        |apply

516     
517         let state = state_rc.borrow();
            |VAR_DECL |assign          |apply

518         let has_pending_ops = !state.pending_ops.is_empty();
            |VAR_DECL           |assign                      |apply

519     
520         let has_pending_dyn_imports = !{
            |VAR_DECL                   |assign
                                           |inner{

521           state.preparing_dyn_imports.is_empty()
                                                  |apply

522             && state.pending_dyn_imports.is_empty()
                                                     |apply

523         };
            |}inner

524         let has_pending_dyn_module_evaluation =
            |VAR_DECL                             |assign

525           !state.pending_dyn_mod_evaluate.is_empty();
                                                      |apply

526         let has_pending_module_evaluation = state.pending_mod_evaluate.is_some();
            |VAR_DECL                         |assign                             |apply

527     
528         if !has_pending_ops
            |IF

529           && !has_pending_dyn_imports
530           && !has_pending_dyn_module_evaluation
531           && !has_pending_module_evaluation
532         {
            |if{

533           return Poll::Ready(Ok(()));
              |RETURN           |apply
                                 |ARG |
                                   |apply
                                    |ARG
                                    |tuple(
                                     |)tuple

534         }
            |}if

535     
536         // Check if more async ops have been dispatched
537         // during this turn of event loop.
538         if state.have_unpolled_ops.get() {
            |IF                           |apply
                                             |if{

539           state.waker.wake();
                              |apply

540         }
            |}if

541     
542         if has_pending_module_evaluation {
            |IF                              |if{

543           if has_pending_ops
              |IF

544             || has_pending_dyn_imports
545             || has_pending_dyn_module_evaluation
546           {
              |if{

547             // pass, will be polled again
548           } else {
              |}if
                |ELSE|else{

549             let msg = "Module evaluation is still pending but there are no pending ops or dynamic imports. This situation is often caused by unresolved promise.";
                |VAR_DECL
                        |assign

550             return Poll::Ready(Err(generic_error(msg)));
                |RETURN           |apply
                                   |ARG                  |
                                      |apply
                                       |ARG             |
                                                    |apply
                                                     |ARG

551           }
              |else}

552         }
            |}if

553     
554         if has_pending_dyn_module_evaluation {
            |IF                                  |if{

555           if has_pending_ops || has_pending_dyn_imports {
              |IF                                           |if{

556             // pass, will be polled again
557           } else {
              |}if
                |ELSE|else{

558             let msg = "Dynamically imported module evaluation is still pending but there are no pending ops. This situation is often caused by unresolved promise.";
                |VAR_DECL
                        |assign

559             return Poll::Ready(Err(generic_error(msg)));
                |RETURN           |apply
                                   |ARG                  |
                                      |apply
                                       |ARG             |
                                                    |apply
                                                     |ARG

560           }
              |else}

561         }
            |}if

562     
563         Poll::Pending
564       }
          |}func

565     }
        |}impl

566     
567     extern "C" fn near_heap_limit_callback<F>(
                   |FUNCTION                   |<t>

568       data: *mut c_void,
          |PARAM          |

569       current_heap_limit: usize,
          |PARAM                  |

570       initial_heap_limit: usize,
          |PARAM                  |

571     ) -> usize
572     where
573       F: FnMut(usize, usize) -> usize,
574     {
        |func{

575       let callback = unsafe { &mut *(data as *mut F) };
          |VAR_DECL    |assign  |inner{                  |}inner

576       callback(current_heap_limit, initial_heap_limit)
                  |apply
                   |ARG             |  |ARG             |

577     }
        |}func

578     
579     impl JsRuntimeState {
        |IMPL               |impl{

580       // Called by V8 during `Isolate::mod_instantiate`.
581       pub fn dyn_import_cb(
              |FUNCTION

582         &mut self,
            |PARAM  |

583         resolver_handle: v8::Global<v8::PromiseResolver>,
            |PARAM                                         |

584         specifier: &str,
            |PARAM        |

585         referrer: &str,
            |PARAM       |

586       ) {
            |func{

587         debug!("dyn_import specifier {} referrer {} ", specifier, referrer);
            |MACRO()
                  |macro(){                                                   |}macro()

588     
589         let load = RecursiveModuleLoad::dynamic_import(
            |VAR_DECL|assign                              |apply

590           self.op_state.clone(),
              |ARG                |
                                 |apply

591           specifier,
              |ARG    |

592           referrer,
              |ARG   |

593           self.loader.clone(),
              |ARG              |
                               |apply

594         );
595         self.dyn_import_map.insert(load.id, resolver_handle);
                                      |apply
                                       |ARG  |  |ARG          |

596         self.waker.wake();
                           |apply

597         let fut = load.prepare().boxed_local();
            |VAR_DECL
                    |assign       |apply        |apply

598         self.preparing_dyn_imports.push(fut);
                                           |apply
                                            |ARG

599       }
          |}func

600     }
        |}impl

601     
602     pub(crate) fn exception_to_err_result<'s, T>(
                   |FUNCTION                  |<T>|<t>

603       scope: &mut v8::HandleScope<'s>,
          |PARAM                        |

604       exception: v8::Local<v8::Value>,
          |PARAM                        |

605       in_promise: bool,
          |PARAM         |

606     ) -> Result<T, AnyError> {
                                 |func{

607       // TODO(piscisaureus): in rusty_v8, `is_execution_terminating()` should
608       // also be implemented on `struct Isolate`.
609       let is_terminating_exception =
          |VAR_DECL                    |assign

610         scope.thread_safe_handle().is_execution_terminating();
                                    |apply                     |apply

611       let mut exception = exception;
          |VAR_DECL         |assign

612     
613       if is_terminating_exception {
          |IF                         |if{

614         // TerminateExecution was called. Cancel exception termination so that the
615         // exception can be created..
616         // TODO(piscisaureus): in rusty_v8, `cancel_terminate_execution()` should
617         // also be implemented on `struct Isolate`.
618         scope.thread_safe_handle().cancel_terminate_execution();
                                    |apply                       |apply

619     
620         // Maybe make a new exception object.
621         if exception.is_null_or_undefined() {
            |IF                              |apply
                                                |if{

622           let message = v8::String::new(scope, "execution terminated").unwrap();
              |VAR_DECL   |assign          |apply
                                            |ARG|  |ARG                 |        |apply

623           exception = v8::Exception::error(scope, message);
                        |assign               |apply
                                               |ARG|  |ARG  |

624         }
            |}if

625       }
          |}if

626     
627       let mut js_error = JsError::from_v8_exception(scope, exception);
          |VAR_DECL        |assign                     |apply
                                                        |ARG|  |ARG    |

628       if in_promise {
          |IF           |if{

629         js_error.message = format!(
                             |assign
                               |MACRO()
                                      |macro(){

630           "Uncaught (in promise) {}",
631           js_error.message.trim_start_matches("Uncaught ")
632         );
            |}macro()

633       }
          |}if

634     
635       let state_rc = JsRuntime::state(scope);
          |VAR_DECL    |assign           |apply
                                          |ARG|

636       let state = state_rc.borrow();
          |VAR_DECL |assign          |apply

637       let js_error = (state.js_error_create_fn)(js_error);
          |VAR_DECL    |assign
                         |apply                    |apply
                                                    |ARG   |

638     
639       if is_terminating_exception {
          |IF                         |if{

640         // Re-enable exception termination.
641         // TODO(piscisaureus): in rusty_v8, `terminate_execution()` should also
642         // be implemented on `struct Isolate`.
643         scope.thread_safe_handle().terminate_execution();
                                    |apply                |apply

644       }
          |}if

645     
646       Err(js_error)
             |apply
              |ARG   |

647     }
        |}func

648     
649     // Related to module loading
650     impl JsRuntime {
        |IMPL          |impl{

651       /// Low-level module creation.
652       ///
653       /// Called during module loading or dynamic import loading.
654       fn mod_new(
          |FUNCTION

655         &mut self,
            |PARAM  |

656         main: bool,
            |PARAM   |

657         name: &str,
            |PARAM   |

658         source: &str,
            |PARAM     |

659       ) -> Result<ModuleId, AnyError> {
                                          |func{

660         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

661         let context = self.global_context();
            |VAR_DECL   |assign              |apply

662         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

663     
664         let name_str = v8::String::new(scope, name).unwrap();
            |VAR_DECL    |assign          |apply
                                           |ARG|  |ARG        |apply

665         let source_str = v8::String::new(scope, source).unwrap();
            |VAR_DECL      |assign          |apply
                                             |ARG|  |ARG |        |apply

666     
667         let origin = bindings::module_origin(scope, name_str);
            |VAR_DECL  |assign                  |apply
                                                 |ARG|  |ARG   |

668         let source = v8::script_compiler::Source::new(source_str, &origin);
            |VAR_DECL  |assign                           |apply
                                                          |ARG     |  |ARG  |

669     
670         let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|

671     
672         let maybe_module = v8::script_compiler::compile_module(tc_scope, source);
            |VAR_DECL        |assign                              |apply
                                                                   |ARG   |  |ARG |

673     
674         if tc_scope.has_caught() {
            |IF                   |apply
                                     |if{

675           assert!(maybe_module.is_none());
              |MACRO()
                     |macro(){              |}macro()

676           let e = tc_scope.exception().unwrap();
              |VAR_DECL
                    |assign             |apply   |apply

677           return exception_to_err_result(tc_scope, e, false);
              |RETURN                       |apply
                                             |ARG   |  |arg
                                                          |ARG|

678         }
            |}if

679     
680         let module = maybe_module.unwrap();
            |VAR_DECL  |assign              |apply

681     
682         let mut import_specifiers: Vec<ModuleSpecifier> = vec![];
            |VAR_DECL                                       |assign
                                                              |MACRO()
                                                                  |macro(){
                                                                   |}macro()

683         for i in 0..module.get_module_requests_length() {
            |FOR                                         |apply
                                                            |for{

684           let import_specifier =
              |VAR_DECL            |assign

685             module.get_module_request(i).to_rust_string_lossy(tc_scope);
                                         |apply
                                          |arg                   |apply
                                                                  |ARG   |

686           let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

687           let module_specifier = state.loader.resolve(
              |VAR_DECL            |assign               |apply

688             state.op_state.clone(),
                |ARG                 |
                                    |apply

689             &import_specifier,
                |ARG            |

690             name,
                |ARG

691             false,
                |ARG|

692           )?;
693           import_specifiers.push(module_specifier);
                                    |apply
                                     |ARG           |

694         }
            |}for

695     
696         let id = state_rc.borrow_mut().modules.register(
            |VAR_DECL
                   |assign              |apply             |apply

697           name,
              |ARG

698           main,
              |ARG

699           v8::Global::<v8::Module>::new(tc_scope, module),
              |ARG                                          |
                           |T_ARG   |      |apply
                                            |ARG   |  |ARG |

700           import_specifiers,
              |ARG            |

701         );
702     
703         Ok(id)
              |apply
               |ARG

704       }
          |}func

705     
706       /// Instantiates a ES module
707       ///
708       /// `AnyError` can be downcast to a type that exposes additional information
709       /// about the V8 exception. By default this type is `JsError`, however it may
710       /// be a different type if `RuntimeOptions::js_error_create_fn` has been set.
711       fn mod_instantiate(&mut self, id: ModuleId) -> Result<(), AnyError> {
          |FUNCTION          |PARAM  |  |PARAM     |                          |func{

712         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

713         let context = self.global_context();
            |VAR_DECL   |assign              |apply

714     
715         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

716         let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|

717     
718         let module = state_rc
            |VAR_DECL  |assign

719           .borrow()
                     |apply

720           .modules
721           .get_handle(id)
                         |apply
                          |ARG

722           .map(|handle| v8::Local::new(tc_scope, handle))
                  |apply
                   |ARG                                    |
                   |closure
                    |PARAM  |CLOSURE{
                            |RETURN       |apply
                                           |ARG   |  |ARG ||}closure

723           .expect("ModuleInfo not found");
                     |apply
                      |ARG                 |

724     
725         if module.get_status() == v8::ModuleStatus::Errored {
            |IF                 |apply                          |if{

726           exception_to_err_result(tc_scope, module.get_exception(), false)?
                                     |apply
                                      |ARG   |  |ARG                 |
                                                                    |apply
                                                                        |ARG|

727         }
            |}if

728     
729         let result =
            |VAR_DECL  |assign

730           module.instantiate_module(tc_scope, bindings::module_resolve_callback);
                                       |apply
                                        |ARG   |  |ARG                            |

731         match result {
            |MATCH       |match{

732           Some(_) => Ok(()),
              |CASE
              |STRUCT()
                   |arg    |apply
                            |ARG
                            |tuple(
                             |)tuple

733           None => {
              |CASE   |inner{

734             let exception = tc_scope.exception().unwrap();
                |VAR_DECL     |assign             |apply   |apply

735             exception_to_err_result(tc_scope, exception, false)
                                       |apply
                                        |ARG   |  |ARG    |  |ARG|

736           }
              |}inner

737         }
            |}match

738       }
          |}func

739     
740       /// Evaluates an already instantiated ES module.
741       ///
742       /// `AnyError` can be downcast to a type that exposes additional information
743       /// about the V8 exception. By default this type is `JsError`, however it may
744       /// be a different type if `RuntimeOptions::js_error_create_fn` has been set.
745       pub fn dyn_mod_evaluate(
              |FUNCTION

746         &mut self,
            |PARAM  |

747         load_id: ModuleLoadId,
            |PARAM              |

748         id: ModuleId,
            |PARAM     |

749       ) -> Result<(), AnyError> {
                                    |func{

750         self.shared_init();
                            |apply

751     
752         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

753         let context = self.global_context();
            |VAR_DECL   |assign              |apply

754         let context1 = self.global_context();
            |VAR_DECL    |assign              |apply

755     
756         let module_handle = state_rc
            |VAR_DECL         |assign

757           .borrow()
                     |apply

758           .modules
759           .get_handle(id)
                         |apply
                          |ARG

760           .expect("ModuleInfo not found");
                     |apply
                      |ARG                 |

761     
762         let status = {
            |VAR_DECL  |assign
                         |inner{

763           let scope =
              |VAR_DECL |assign

764             &mut v8::HandleScope::with_context(self.v8_isolate(), context);
                                                  |apply
                                                   |ARG            |
                                                                  |apply
                                                                      |ARG  |

765           let module = module_handle.get(scope);
              |VAR_DECL  |assign            |apply
                                             |ARG|

766           module.get_status()
                               |apply

767         };
            |}inner

768     
769         if status == v8::ModuleStatus::Instantiated {
            |IF                                         |if{

770           // IMPORTANT: Top-level-await is enabled, which means that return value
771           // of module evaluation is a promise.
772           //
773           // Because that promise is created internally by V8, when error occurs during
774           // module evaluation the promise is rejected, and since the promise has no rejection
775           // handler it will result in call to `bindings::promise_reject_callback` adding
776           // the promise to pending promise rejection table - meaning JsRuntime will return
777           // error on next poll().
778           //
779           // This situation is not desirable as we want to manually return error at the
780           // end of this function to handle it further. It means we need to manually
781           // remove this promise from pending promise rejection table.
782           //
783           // For more details see:
784           // https://github.com/denoland/deno/issues/4908
785           // https://v8.dev/features/top-level-await#module-execution-order
786           let scope =
              |VAR_DECL |assign

787             &mut v8::HandleScope::with_context(self.v8_isolate(), context1);
                                                  |apply
                                                   |ARG            |
                                                                  |apply
                                                                      |ARG   |

788           let module = v8::Local::new(scope, &module_handle);
              |VAR_DECL  |assign         |apply
                                          |ARG|  |ARG         |

789           let maybe_value = module.evaluate(scope);
              |VAR_DECL       |assign          |apply
                                                |ARG|

790     
791           // Update status after evaluating.
792           let status = module.get_status();
              |VAR_DECL  |assign            |apply

793     
794           if let Some(value) = maybe_value {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG|  |assign       |if{

795             assert!(
                |MACRO()
                       |macro(){

796               status == v8::ModuleStatus::Evaluated
797                 || status == v8::ModuleStatus::Errored
798             );
                |}macro()

799             let promise = v8::Local::<v8::Promise>::try_from(value)
                |VAR_DECL   |assign       |T_ARG    |           |apply
                                                                 |ARG|

800               .expect("Expected to get promise as module evaluation result");
                         |apply
                          |ARG                                                |

801             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |

802             let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply

803             state.pending_promise_exceptions.remove(&promise_global);
                                                       |apply
                                                        |ARG          |

804             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |

805             let module_global = v8::Global::new(scope, module);
                |VAR_DECL         |assign          |apply
                                                    |ARG|  |ARG |

806     
807             let dyn_import_mod_evaluate = DynImportModEvaluate {
                |VAR_DECL                   |assign
                                              |STRUCT()          |

808               module_id: id,
                  |ARG        |

809               promise: promise_global,
                  |ARG                  |

810               module: module_global,
                  |ARG                |

811             };
812     
813             state
814               .pending_dyn_mod_evaluate
815               .insert(load_id, dyn_import_mod_evaluate);
                         |apply
                          |ARG  |  |ARG                  |

816           } else {
              |}if
                |ELSE|else{

817             assert!(status == v8::ModuleStatus::Errored);
                |MACRO()
                       |macro(){                           |}macro()

818           }
              |else}

819         }
            |}if

820     
821         if status == v8::ModuleStatus::Evaluated {
            |IF                                      |if{

822           self.dyn_import_done(load_id, id);
                                  |apply
                                   |ARG  |  |ARG

823         }
            |}if

824     
825         Ok(())
              |apply
               |ARG
               |tuple(
                |)tuple

826       }
          |}func

827     
828       /// Evaluates an already instantiated ES module.
829       ///
830       /// `AnyError` can be downcast to a type that exposes additional information
831       /// about the V8 exception. By default this type is `JsError`, however it may
832       /// be a different type if `RuntimeOptions::js_error_create_fn` has been set.
833       fn mod_evaluate_inner(
          |FUNCTION

834         &mut self,
            |PARAM  |

835         id: ModuleId,
            |PARAM     |

836       ) -> mpsc::Receiver<Result<(), AnyError>> {
                                                    |func{

837         self.shared_init();
                            |apply

838     
839         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

840         let context = self.global_context();
            |VAR_DECL   |assign              |apply

841     
842         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

843     
844         let module = state_rc
            |VAR_DECL  |assign

845           .borrow()
                     |apply

846           .modules
847           .get_handle(id)
                         |apply
                          |ARG

848           .map(|handle| v8::Local::new(scope, handle))
                  |apply
                   |ARG                                 |
                   |closure
                    |PARAM  |CLOSURE{
                            |RETURN       |apply
                                           |ARG|  |ARG ||}closure

849           .expect("ModuleInfo not found");
                     |apply
                      |ARG                 |

850         let mut status = module.get_status();
            |VAR_DECL      |assign            |apply

851     
852         let (sender, receiver) = mpsc::channel(1);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM |T_ELEM||)tuple
                                   |assign        |apply
                                                   |arg

853     
854         if status == v8::ModuleStatus::Instantiated {
            |IF                                         |if{

855           // IMPORTANT: Top-level-await is enabled, which means that return value
856           // of module evaluation is a promise.
857           //
858           // Because that promise is created internally by V8, when error occurs during
859           // module evaluation the promise is rejected, and since the promise has no rejection
860           // handler it will result in call to `bindings::promise_reject_callback` adding
861           // the promise to pending promise rejection table - meaning JsRuntime will return
862           // error on next poll().
863           //
864           // This situation is not desirable as we want to manually return error at the
865           // end of this function to handle it further. It means we need to manually
866           // remove this promise from pending promise rejection table.
867           //
868           // For more details see:
869           // https://github.com/denoland/deno/issues/4908
870           // https://v8.dev/features/top-level-await#module-execution-order
871           let maybe_value = module.evaluate(scope);
              |VAR_DECL       |assign          |apply
                                                |ARG|

872     
873           // Update status after evaluating.
874           status = module.get_status();
                     |assign            |apply

875     
876           if let Some(value) = maybe_value {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG|  |assign       |if{

877             assert!(
                |MACRO()
                       |macro(){

878               status == v8::ModuleStatus::Evaluated
879                 || status == v8::ModuleStatus::Errored
880             );
                |}macro()

881             let promise = v8::Local::<v8::Promise>::try_from(value)
                |VAR_DECL   |assign       |T_ARG    |           |apply
                                                                 |ARG|

882               .expect("Expected to get promise as module evaluation result");
                         |apply
                          |ARG                                                |

883             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |

884             let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply

885             state.pending_promise_exceptions.remove(&promise_global);
                                                       |apply
                                                        |ARG          |

886             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |

887             assert!(
                |MACRO()
                       |macro(){

888               state.pending_mod_evaluate.is_none(),
889               "There is already pending top level module evaluation"
890             );
                |}macro()

891     
892             state.pending_mod_evaluate = Some(ModEvaluate {
                                           |assign
                                                 |apply
                                                  |ARG        |
                                                  |STRUCT() |

893               promise: promise_global,
                  |ARG                  |

894               sender,
                  |ARG |

895             });
896             scope.perform_microtask_checkpoint();
                                                  |apply

897           } else {
              |}if
                |ELSE|else{

898             assert!(status == v8::ModuleStatus::Errored);
                |MACRO()
                       |macro(){                           |}macro()

899           }
              |else}

900         }
            |}if

901     
902         receiver
903       }
          |}func

904     
905       pub async fn mod_evaluate(&mut self, id: ModuleId) -> Result<(), AnyError> {
                    |FUNCTION       |PARAM  |  |PARAM     |                          |func{

906         let mut receiver = self.mod_evaluate_inner(id);
            |VAR_DECL        |assign                  |apply
                                                       |ARG

907     
908         poll_fn(|cx| {
                   |apply
                    |ARG |
                    |closure
                     |PARAM
                         |closure{
                         |return
                         |inner{

909           if let Poll::Ready(maybe_result) = receiver.poll_next_unpin(cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG       |  |assign                   |apply
                                                                          |ARG|if{

910             debug!("received module evaluate {:#?}", maybe_result);
                |MACRO()
                      |macro(){                                      |}macro()

911             // If `None` is returned it means that runtime was destroyed before
912             // evaluation was complete. This can happen in Web Worker when `self.close()`
913             // is called at top level.
914             let result = maybe_result.unwrap_or(Ok(()));
                |VAR_DECL  |assign                 |apply
                                                    |ARG |
                                                      |apply
                                                       |ARG
                                                       |tuple(
                                                        |)tuple

915             return Poll::Ready(result);
                |RETURN           |apply
                                   |ARG |

916           }
              |}if

917           let _r = self.poll_event_loop(cx)?;
              |VAR_DECL
                     |assign               |apply
                                            |ARG

918           Poll::Pending
919         })
            |}inner
            |}closure

920         .await
921       }
          |}func

922     
923       fn dyn_import_error(&mut self, id: ModuleLoadId, err: AnyError) {
          |FUNCTION           |PARAM  |  |PARAM         |  |PARAM      |  |func{

924         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

925         let context = self.global_context();
            |VAR_DECL   |assign              |apply

926     
927         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

928     
929         let resolver_handle = state_rc
            |VAR_DECL           |assign

930           .borrow_mut()
                         |apply

931           .dyn_import_map
932           .remove(&id)
                     |apply
                      |ARG

933           .expect("Invalid dyn import id");
                     |apply
                      |ARG                  |

934         let resolver = resolver_handle.get(scope);
            |VAR_DECL    |assign              |apply
                                               |ARG|

935     
936         let exception = err
            |VAR_DECL     |assign

937           .downcast_ref::<ErrWithV8Handle>()
                              |T_ARG        | |apply

938           .map(|err| err.get_handle(scope))
                  |apply
                   |ARG                      |
                   |closure
                    |PARAM
                         |CLOSURE{
                         |RETURN       |apply
                                        |ARG||}closure

939           .unwrap_or_else(|| {
                             |apply
                              |ARG|
                              |CLOSURE
                                 |closure{
                                 |return
                                 |inner{

940             let message = err.to_string();
                |VAR_DECL   |assign        |apply

941             let message = v8::String::new(scope, &message).unwrap();
                |VAR_DECL   |assign          |apply
                                              |ARG|  |ARG   |        |apply

942             v8::Exception::type_error(scope, message)
                                         |apply
                                          |ARG|  |ARG  |

943           });
              |}inner
              |}closure

944     
945         resolver.reject(scope, exception).unwrap();
                           |apply
                            |ARG|  |ARG    |        |apply

946         scope.perform_microtask_checkpoint();
                                              |apply

947       }
          |}func

948     
949       fn dyn_import_done(&mut self, id: ModuleLoadId, mod_id: ModuleId) {
          |FUNCTION          |PARAM  |  |PARAM         |  |PARAM         |  |func{

950         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

951         let context = self.global_context();
            |VAR_DECL   |assign              |apply

952     
953         debug!("dyn_import_done {} {:?}", id, mod_id);
            |MACRO()
                  |macro(){                             |}macro()

954         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

955     
956         let resolver_handle = state_rc
            |VAR_DECL           |assign

957           .borrow_mut()
                         |apply

958           .dyn_import_map
959           .remove(&id)
                     |apply
                      |ARG

960           .expect("Invalid dyn import id");
                     |apply
                      |ARG                  |

961         let resolver = resolver_handle.get(scope);
            |VAR_DECL    |assign              |apply
                                               |ARG|

962     
963         let module = {
            |VAR_DECL  |assign
                         |inner{

964           let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

965           state
966             .modules
967             .get_handle(mod_id)
                           |apply
                            |ARG |

968             .map(|handle| v8::Local::new(scope, handle))
                    |apply
                     |ARG                                 |
                     |closure
                      |PARAM  |CLOSURE{
                              |RETURN       |apply
                                             |ARG|  |ARG ||}closure

969             .expect("Dyn import module info not found")
                       |apply
                        |ARG                             |

970         };
            |}inner

971         // Resolution success
972         assert_eq!(module.get_status(), v8::ModuleStatus::Evaluated);
            |MACRO()| |macro(){                                        |}macro()

973     
974         let module_namespace = module.get_module_namespace();
            |VAR_DECL            |assign                      |apply

975         resolver.resolve(scope, module_namespace).unwrap();
                            |apply
                             |ARG|  |ARG           |        |apply

976         scope.perform_microtask_checkpoint();
                                              |apply

977       }
          |}func

978     
979       fn prepare_dyn_imports(
          |FUNCTION

980         &mut self,
            |PARAM  |

981         cx: &mut Context,
            |PARAM         |

982       ) -> Poll<Result<(), AnyError>> {
                                          |func{

983         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

984     
985         if state_rc.borrow().preparing_dyn_imports.is_empty() {
            |IF               |apply                           |apply
                                                                  |if{

986           return Poll::Ready(Ok(()));
              |RETURN           |apply
                                 |ARG |
                                   |apply
                                    |ARG
                                    |tuple(
                                     |)tuple

987         }
            |}if

988     
989         loop {
            |LOOP|loop{

990           let r = {
              |VAR_DECL
                    |assign
                      |inner{

991             let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply

992             state.preparing_dyn_imports.poll_next_unpin(cx)
                                                           |apply
                                                            |ARG

993           };
              |}inner

994           match r {
              |MATCH  |match{

995             Poll::Pending | Poll::Ready(None) => {
                |CASE           |STRUCT()   |ARG     |inner{

996               // There are no active dynamic import loaders, or none are ready.
997               return Poll::Ready(Ok(()));
                  |RETURN           |apply
                                     |ARG |
                                       |apply
                                        |ARG
                                        |tuple(
                                         |)tuple

998             }
                |}inner

999             Poll::Ready(Some(prepare_poll)) => {
                |CASE
                |STRUCT()   |ARG             |
                            |STRUCT()
                                 |ARG       |      |inner{

1000              let dyn_import_id = prepare_poll.0;
                  |VAR_DECL         |assign

1001              let prepare_result = prepare_poll.1;
                  |VAR_DECL          |assign

1002    
1003              match prepare_result {
                  |MATCH               |match{

1004                Ok(load) => {
                    |CASE
                    |STRUCT()
                       |ARG     |inner{

1005                  let state = state_rc.borrow_mut();
                      |VAR_DECL |assign              |apply

1006                  state.pending_dyn_imports.push(load.into_future());
                                                    |apply
                                                     |ARG             |
                                                                     |apply

1007                }
                    |}inner

1008                Err(err) => {
                    |CASE
                    |STRUCT()
                        |ARG    |inner{

1009                  self.dyn_import_error(dyn_import_id, err);
                                           |apply
                                            |ARG        |  |ARG

1010                }
                    |}inner

1011              }
                  |}match

1012            }
                |}inner

1013          }
              |}match

1014        }
            |}loop

1015      }
          |}func

1016    
1017      fn poll_dyn_imports(
          |FUNCTION

1018        &mut self,
            |PARAM  |

1019        cx: &mut Context,
            |PARAM         |

1020      ) -> Poll<Result<(), AnyError>> {
                                          |func{

1021        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

1022    
1023        if state_rc.borrow().pending_dyn_imports.is_empty() {
            |IF               |apply                         |apply
                                                                |if{

1024          return Poll::Ready(Ok(()));
              |RETURN           |apply
                                 |ARG |
                                   |apply
                                    |ARG
                                    |tuple(
                                     |)tuple

1025        }
            |}if

1026    
1027        loop {
            |LOOP|loop{

1028          let poll_result = {
              |VAR_DECL       |assign
                                |inner{

1029            let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply

1030            state.pending_dyn_imports.poll_next_unpin(cx)
                                                         |apply
                                                          |ARG

1031          };
              |}inner

1032    
1033          match poll_result {
              |MATCH            |match{

1034            Poll::Pending | Poll::Ready(None) => {
                |CASE           |STRUCT()   |ARG     |inner{

1035              // There are no active dynamic import loaders, or none are ready.
1036              return Poll::Ready(Ok(()));
                  |RETURN           |apply
                                     |ARG |
                                       |apply
                                        |ARG
                                        |tuple(
                                         |)tuple

1037            }
                |}inner

1038            Poll::Ready(Some(load_stream_poll)) => {
                |CASE
                |STRUCT()   |ARG                 |
                            |STRUCT()
                                 |ARG           |      |inner{

1039              let maybe_result = load_stream_poll.0;
                  |VAR_DECL        |assign

1040              let mut load = load_stream_poll.1;
                  |VAR_DECL    |assign

1041              let dyn_import_id = load.id;
                  |VAR_DECL         |assign

1042    
1043              if let Some(load_stream_result) = maybe_result {
                  |IF|VAR_DECL
                         |STRUCT()
                              |ARG             |  |assign        |if{

1044                match load_stream_result {
                    |MATCH                   |match{

1045                  Ok(info) => {
                      |CASE
                      |STRUCT()
                         |ARG     |inner{

1046                    // A module (not necessarily the one dynamically imported) has been
1047                    // fetched. Create and register it, and if successful, poll for the
1048                    // next recursive-load event related to this dynamic import.
1049                    match self.register_during_load(info, &mut load) {
                        |MATCH                         |apply
                                                        |ARG  |ARG    |  |match{

1050                      Ok(()) => {
                          |CASE
                          |STRUCT()
                             |ARG
                             |tuple
                             |tuple(
                              |)tuple
                                    |inner{

1051                        // Keep importing until it's fully drained
1052                        let state = state_rc.borrow_mut();
                            |VAR_DECL |assign              |apply

1053                        state.pending_dyn_imports.push(load.into_future());
                                                          |apply
                                                           |ARG             |
                                                                           |apply

1054                      }
                          |}inner

1055                      Err(err) => self.dyn_import_error(dyn_import_id, err),
                          |CASE
                          |STRUCT()
                              |ARG                         |apply
                                                            |ARG        |  |ARG

1056                    }
                        |}match

1057                  }
                      |}inner

1058                  Err(err) => {
                      |CASE
                      |STRUCT()
                          |ARG    |inner{

1059                    // A non-javascript error occurred; this could be due to a an invalid
1060                    // module specifier, or a problem with the source map, or a failure
1061                    // to fetch the module source code.
1062                    self.dyn_import_error(dyn_import_id, err)
                                             |apply
                                              |ARG        |  |ARG

1063                  }
                      |}inner

1064                }
                    |}match

1065              } else {
                  |}if
                    |ELSE|else{

1066                // The top-level module from a dynamic import has been instantiated.
1067                // Load is done.
1068                let module_id = load.root_module_id.unwrap();
                    |VAR_DECL     |assign                     |apply

1069                self.mod_instantiate(module_id)?;
                                        |apply
                                         |ARG    |

1070                self.dyn_mod_evaluate(dyn_import_id, module_id)?;
                                         |apply
                                          |ARG        |  |ARG    |

1071              }
                  |else}

1072            }
                |}inner

1073          }
              |}match

1074        }
            |}loop

1075      }
          |}func

1076    
1077      /// "deno_core" runs V8 with "--harmony-top-level-await"
1078      /// flag on - it means that each module evaluation returns a promise
1079      /// from V8.
1080      ///
1081      /// This promise resolves after all dependent modules have also
1082      /// resolved. Each dependent module may perform calls to "import()" and APIs
1083      /// using async ops will add futures to the runtime's event loop.
1084      /// It means that the promise returned from module evaluation will
1085      /// resolve only after all futures in the event loop are done.
1086      ///
1087      /// Thus during turn of event loop we need to check if V8 has
1088      /// resolved or rejected the promise. If the promise is still pending
1089      /// then another turn of event loop must be performed.
1090      fn evaluate_pending_module(&mut self) {
          |FUNCTION                  |PARAM  |  |func{

1091        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

1092    
1093        let context = self.global_context();
            |VAR_DECL   |assign              |apply

1094        {
            |inner{

1095          let scope =
              |VAR_DECL |assign

1096            &mut v8::HandleScope::with_context(self.v8_isolate(), context);
                                                  |apply
                                                   |ARG            |
                                                                  |apply
                                                                      |ARG  |

1097    
1098          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply

1099    
1100          if let Some(module_evaluation) = state.pending_mod_evaluate.as_ref() {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG            |  |assign                            |apply
                                                                                   |if{

1101            let promise = module_evaluation.promise.get(scope);
                |VAR_DECL   |assign                        |apply
                                                            |ARG|

1102            let mut sender = module_evaluation.sender.clone();
                |VAR_DECL      |assign                         |apply

1103            let promise_state = promise.state();
                |VAR_DECL         |assign        |apply

1104    
1105            match promise_state {
                |MATCH              |match{

1106              v8::PromiseState::Pending => {
                  |CASE                        |inner{

1107                // pass, poll_event_loop will decide if
1108                // runtime would be woken soon
1109              }
                  |}inner

1110              v8::PromiseState::Fulfilled => {
                  |CASE                          |inner{

1111                state.pending_mod_evaluate.take();
                                                   |apply

1112                scope.perform_microtask_checkpoint();
                                                      |apply

1113                sender.try_send(Ok(())).unwrap();
                                   |apply
                                    |ARG |
                                      |apply
                                       |ARG
                                       |tuple(
                                        |)tuple   |apply

1114              }
                  |}inner

1115              v8::PromiseState::Rejected => {
                  |CASE                         |inner{

1116                let exception = promise.result(scope);
                    |VAR_DECL     |assign         |apply
                                                   |ARG|

1117                state.pending_mod_evaluate.take();
                                                   |apply

1118                drop(state);
                        |apply
                         |ARG|

1119                scope.perform_microtask_checkpoint();
                                                      |apply

1120                let err1 = exception_to_err_result::<()>(scope, exception, false)
                    |VAR_DECL|assign                     |T_ARG
                                                            |apply
                                                             |ARG|  |ARG    |  |ARG|

1121                  .map_err(|err| attach_handle_to_error(scope, err, exception))
                              |apply
                               |ARG                                              |
                               |closure
                                |PARAM
                                     |CLOSURE{            |
                                     |RETURN              ||apply
                                                            |ARG|  |ARG |ARG    ||}closure

1122                  .unwrap_err();
                                 |apply

1123                sender.try_send(Err(err1)).unwrap();
                                   |apply
                                    |ARG    |
                                       |apply
                                        |ARG         |apply

1124              }
                  |}inner

1125            }
                |}match

1126          }
              |}if

1127        };
            |}inner

1128      }
          |}func

1129    
1130      fn evaluate_dyn_imports(&mut self) {
          |FUNCTION               |PARAM  |  |func{

1131        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

1132    
1133        loop {
            |LOOP|loop{

1134          let context = self.global_context();
              |VAR_DECL   |assign              |apply

1135          let maybe_result = {
              |VAR_DECL        |assign
                                 |inner{

1136            let scope =
                |VAR_DECL |assign

1137              &mut v8::HandleScope::with_context(self.v8_isolate(), context);
                                                    |apply
                                                     |ARG            |
                                                                    |apply
                                                                        |ARG  |

1138    
1139            let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply

1140            if let Some(&dyn_import_id) =
                |IF|VAR_DECL
                       |STRUCT()
                            |ARG         |  |assign

1141              state.pending_dyn_mod_evaluate.keys().next()
                                                     |apply |apply

1142            {
                |if{

1143              let handle = state
                  |VAR_DECL  |assign

1144                .pending_dyn_mod_evaluate
1145                .remove(&dyn_import_id)
                           |apply
                            |ARG         |

1146                .unwrap();
                           |apply

1147              drop(state);
                      |apply
                       |ARG|

1148    
1149              let module_id = handle.module_id;
                  |VAR_DECL     |assign

1150              let promise = handle.promise.get(scope);
                  |VAR_DECL   |assign             |apply
                                                   |ARG|

1151              let _module = handle.module.get(scope);
                  |VAR_DECL   |assign            |apply
                                                  |ARG|

1152    
1153              let promise_state = promise.state();
                  |VAR_DECL         |assign        |apply

1154    
1155              match promise_state {
                  |MATCH              |match{

1156                v8::PromiseState::Pending => {
                    |CASE                        |inner{

1157                  state_rc
1158                    .borrow_mut()
                                   |apply

1159                    .pending_dyn_mod_evaluate
1160                    .insert(dyn_import_id, handle);
                               |apply
                                |ARG        |  |ARG |

1161                  None
1162                }
                    |}inner

1163                v8::PromiseState::Fulfilled => Some(Ok((dyn_import_id, module_id))),
                    |CASE                              |apply
                                                        |ARG                         |
                                                          |apply
                                                           |ARG                     |
                                                           |tuple(
                                                            |T_ELEM     |  |T_ELEM ||)tuple

1164                v8::PromiseState::Rejected => {
                    |CASE                         |inner{

1165                  let exception = promise.result(scope);
                      |VAR_DECL     |assign         |apply
                                                     |ARG|

1166                  let err1 = exception_to_err_result::<()>(scope, exception, false)
                      |VAR_DECL|assign                     |T_ARG
                                                              |apply
                                                               |ARG|  |ARG    |  |ARG|

1167                    .map_err(|err| attach_handle_to_error(scope, err, exception))
                                |apply
                                 |ARG                                              |
                                 |closure
                                  |PARAM
                                       |CLOSURE{            |
                                       |RETURN              ||apply
                                                              |ARG|  |ARG |ARG    ||}closure

1168                    .unwrap_err();
                                   |apply

1169                  Some(Err((dyn_import_id, err1)))
                          |apply
                           |ARG                     |
                              |apply
                               |ARG                |
                               |tuple(
                                |T_ELEM     |  |T_ELEM
                                                   |)tuple

1170                }
                    |}inner

1171              }
                  |}match

1172            } else {
                |}if
                  |ELSE|else{

1173              None
1174            }
                |else}

1175          };
              |}inner

1176    
1177          if let Some(result) = maybe_result {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG |  |assign        |if{

1178            match result {
                |MATCH       |match{

1179              Ok((dyn_import_id, module_id)) => {
                  |CASE
                  |STRUCT()
                     |ARG                     |
                     |tuple
                     |tuple(
                      |T_ELEM     |  |T_ELEM ||)tuple
                                                    |inner{

1180                self.dyn_import_done(dyn_import_id, module_id);
                                        |apply
                                         |ARG        |  |ARG    |

1181              }
                  |}inner

1182              Err((dyn_import_id, err1)) => {
                  |CASE
                  |STRUCT()
                      |ARG                |
                      |tuple
                      |tuple(
                       |T_ELEM     |  |T_ELEM
                                          |)tuple
                                                |inner{

1183                self.dyn_import_error(dyn_import_id, err1);
                                         |apply
                                          |ARG        |  |ARG

1184              }
                  |}inner

1185            }
                |}match

1186          } else {
              |}if
                |ELSE|else{

1187            break;
                |BREAK

1188          }
              |else}

1189        }
            |}loop

1190      }
          |}func

1191    
1192      fn register_during_load(
          |FUNCTION

1193        &mut self,
            |PARAM  |

1194        info: ModuleSource,
            |PARAM           |

1195        load: &mut RecursiveModuleLoad,
            |PARAM                       |

1196      ) -> Result<(), AnyError> {
                                    |func{

1197        let ModuleSource {
            |VAR_DECL
                |STRUCT    | |struct{

1198          code,
              |FIELD

1199          module_url_specified,
              |FIELD             |

1200          module_url_found,
              |FIELD         |

1201        } = info;
            |}struct
              |assign

1202    
1203        let is_main =
            |VAR_DECL   |assign

1204          load.state == LoadState::LoadingRoot && !load.is_dynamic_import();
                                                                             |apply

1205        let referrer_specifier =
            |VAR_DECL              |assign

1206          ModuleSpecifier::resolve_url(&module_url_found).unwrap();
                                          |apply
                                           |ARG            |        |apply

1207    
1208        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

1209        // #A There are 3 cases to handle at this moment:
1210        // 1. Source code resolved result have the same module name as requested
1211        //    and is not yet registered
1212        //     -> register
1213        // 2. Source code resolved result have a different name as requested:
1214        //   2a. The module with resolved module name has been registered
1215        //     -> alias
1216        //   2b. The module with resolved module name has not yet been registered
1217        //     -> register & alias
1218    
1219        // If necessary, register an alias.
1220        if module_url_specified != module_url_found {
            |IF                                         |if{

1221          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply

1222          state
1223            .modules
1224            .alias(&module_url_specified, &module_url_found);
                      |apply
                       |ARG                |  |ARG            |

1225        }
            |}if

1226    
1227        let maybe_mod_id = {
            |VAR_DECL        |assign
                               |inner{

1228          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

1229          state.modules.get_id(&module_url_found)
                                  |apply
                                   |ARG            |

1230        };
            |}inner

1231    
1232        let module_id = match maybe_mod_id {
            |VAR_DECL     |assign
                            |MATCH             |match{

1233          Some(id) => {
              |CASE
              |STRUCT()
                   |ARG   |inner{

1234            // Module has already been registered.
1235            debug!(
                |MACRO()
                      |macro(){

1236              "Already-registered module fetched again: {}",
1237              module_url_found
1238            );
                |}macro()

1239            id
1240          }
              |}inner

1241          // Module not registered yet, do it now.
1242          None => self.mod_new(is_main, &module_url_found, &code)?,
              |CASE               |apply
                                   |ARG  |  |ARG            |  |ARG|

1243        };
            |}match

1244    
1245        // Now we must iterate over all imports of the module and load them.
1246        let imports = {
            |VAR_DECL   |assign
                          |inner{

1247          let state_rc = Self::state(self.v8_isolate());
              |VAR_DECL    |assign      |apply
                                         |ARG            |
                                                        |apply

1248          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

1249          state.modules.get_children(module_id).unwrap().clone()
                                        |apply
                                         |ARG    |        |apply  |apply

1250        };
            |}inner

1251    
1252        for module_specifier in imports {
            |FOR                            |for{

1253          let is_registered = {
              |VAR_DECL         |assign
                                  |inner{

1254            let state_rc = Self::state(self.v8_isolate());
                |VAR_DECL    |assign      |apply
                                           |ARG            |
                                                          |apply

1255            let state = state_rc.borrow();
                |VAR_DECL |assign          |apply

1256            state.modules.is_registered(&module_specifier)
                                           |apply
                                            |ARG            |

1257          };
              |}inner

1258          if !is_registered {
              |IF               |if{

1259            load
1260              .add_import(module_specifier.to_owned(), referrer_specifier.clone());
                             |apply
                              |ARG                      |
                                                       |apply
                                                           |ARG                     |
                                                                                   |apply

1261          }
              |}if

1262        }
            |}for

1263    
1264        // If we just finished loading the root module, store the root module id.
1265        if load.state == LoadState::LoadingRoot {
            |IF                                     |if{

1266          load.root_module_id = Some(module_id);
                                  |assign
                                        |apply
                                         |ARG    |

1267          load.state = LoadState::LoadingImports;
                         |assign

1268        }
            |}if

1269    
1270        if load.pending.is_empty() {
            |IF                     |apply
                                       |if{

1271          load.state = LoadState::Done;
                         |assign

1272        }
            |}if

1273    
1274        Ok(())
              |apply
               |ARG
               |tuple(
                |)tuple

1275      }
          |}func

1276    
1277      /// Asynchronously load specified module and all of its dependencies
1278      ///
1279      /// User must call `JsRuntime::mod_evaluate` with returned `ModuleId`
1280      /// manually after load is finished.
1281      pub async fn load_module(
                    |FUNCTION

1282        &mut self,
            |PARAM  |

1283        specifier: &ModuleSpecifier,
            |PARAM                    |

1284        code: Option<String>,
            |PARAM             |

1285      ) -> Result<ModuleId, AnyError> {
                                          |func{

1286        self.shared_init();
                            |apply

1287        let loader = {
            |VAR_DECL  |assign
                         |inner{

1288          let state_rc = Self::state(self.v8_isolate());
              |VAR_DECL    |assign      |apply
                                         |ARG            |
                                                        |apply

1289          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

1290          state.loader.clone()
                                |apply

1291        };
            |}inner

1292    
1293        let load = RecursiveModuleLoad::main(
            |VAR_DECL|assign                    |apply

1294          self.op_state(),
              |ARG          |
                           |apply

1295          &specifier.to_string(),
              |ARG                 |
                                  |apply

1296          code,
              |ARG

1297          loader,
              |ARG |

1298        );
1299        let (_load_id, prepare_result) = load.prepare().await;
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM|  |T_ELEM      ||)tuple
                                           |assign       |apply

1300    
1301        let mut load = prepare_result?;
            |VAR_DECL    |assign

1302    
1303        while let Some(info_result) = load.next().await {
            |LOOP |VAR_DECL
                      |STRUCT()
                           |ARG      |  |assign    |apply   |loop{

1304          let info = info_result?;
              |VAR_DECL|assign

1305          self.register_during_load(info, &mut load)?;
                                       |apply
                                        |ARG  |ARG    |

1306        }
            |}loop

1307    
1308        let root_id = load.root_module_id.expect("Root module id empty");
            |VAR_DECL   |assign                     |apply
                                                     |ARG                 |

1309        self.mod_instantiate(root_id).map(|_| root_id)
                                |apply
                                 |ARG  |     |apply
                                              |ARG      |
                                              |closure
                                               |param
                                                  |CLOSURE{
                                                  |RETURN
                                                  |}CLOSURE

1310      }
          |}func

1311    
1312      fn poll_pending_ops(
          |FUNCTION

1313        &mut self,
            |PARAM  |

1314        cx: &mut Context,
            |PARAM         |

1315      ) -> Option<(OpId, Box<[u8]>)> {
                                         |func{

1316        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

1317        let mut overflow_response: Option<(OpId, Box<[u8]>)> = None;
            |VAR_DECL                                            |assign

1318    
1319        loop {
            |LOOP|loop{

1320          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply

1321          // Now handle actual ops.
1322          state.have_unpolled_ops.set(false);
                                         |apply
                                          |ARG|

1323    
1324          let pending_r = state.pending_ops.poll_next_unpin(cx);
              |VAR_DECL     |assign                            |apply
                                                                |ARG

1325          match pending_r {
              |MATCH          |match{

1326            Poll::Ready(None) => break,
                |CASE
                |STRUCT()   |ARG     |BREAK

1327            Poll::Pending => break,
                |CASE            |BREAK

1328            Poll::Ready(Some((op_id, buf))) => {
                |CASE
                |STRUCT()   |ARG             |
                            |STRUCT()
                                 |ARG       |
                                 |tuple
                                 |tuple(
                                  |T_ELEM|T_ELEM
                                            |)tuple|inner{

1329              let successful_push = state.shared.push(op_id, &buf);
                  |VAR_DECL           |assign            |apply
                                                          |ARG|  |ARG

1330              if !successful_push {
                  |IF                 |if{

1331                // If we couldn't push the response to the shared queue, because
1332                // there wasn't enough size, we will return the buffer via the
1333                // legacy route, using the argument of deno_respond.
1334                overflow_response = Some((op_id, buf));
                                      |assign
                                            |apply
                                             |ARG       |
                                             |tuple(
                                              |T_ELEM|T_ELEM
                                                        |)tuple

1335                break;
                    |BREAK

1336              }
                  |}if

1337            }
                |}inner

1338          };
              |}match

1339        }
            |}loop

1340    
1341        loop {
            |LOOP|loop{

1342          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply

1343          let unref_r = state.pending_unref_ops.poll_next_unpin(cx);
              |VAR_DECL   |assign                                  |apply
                                                                    |ARG

1344          #[allow(clippy::match_wild_err_arm)]
              |OUTER_ATTR                        |

1345          match unref_r {
              |MATCH        |match{

1346            Poll::Ready(None) => break,
                |CASE
                |STRUCT()   |ARG     |BREAK

1347            Poll::Pending => break,
                |CASE            |BREAK

1348            Poll::Ready(Some((op_id, buf))) => {
                |CASE
                |STRUCT()   |ARG             |
                            |STRUCT()
                                 |ARG       |
                                 |tuple
                                 |tuple(
                                  |T_ELEM|T_ELEM
                                            |)tuple|inner{

1349              let successful_push = state.shared.push(op_id, &buf);
                  |VAR_DECL           |assign            |apply
                                                          |ARG|  |ARG

1350              if !successful_push {
                  |IF                 |if{

1351                // If we couldn't push the response to the shared queue, because
1352                // there wasn't enough size, we will return the buffer via the
1353                // legacy route, using the argument of deno_respond.
1354                overflow_response = Some((op_id, buf));
                                      |assign
                                            |apply
                                             |ARG       |
                                             |tuple(
                                              |T_ELEM|T_ELEM
                                                        |)tuple

1355                break;
                    |BREAK

1356              }
                  |}if

1357            }
                |}inner

1358          };
              |}match

1359        }
            |}loop

1360    
1361        overflow_response
1362      }
          |}func

1363    
1364      fn check_promise_exceptions(&mut self) -> Result<(), AnyError> {
          |FUNCTION                   |PARAM  |                          |func{

1365        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

1366        let mut state = state_rc.borrow_mut();
            |VAR_DECL     |assign              |apply

1367    
1368        if state.pending_promise_exceptions.is_empty() {
            |IF                                         |apply
                                                           |if{

1369          return Ok(());
              |RETURN  |apply
                        |ARG
                        |tuple(
                         |)tuple

1370        }
            |}if

1371    
1372        let key = {
            |VAR_DECL
                    |assign
                      |inner{

1373          state
1374            .pending_promise_exceptions
1375            .keys()
                     |apply

1376            .next()
                     |apply

1377            .unwrap()
                       |apply

1378            .clone()
                      |apply

1379        };
            |}inner

1380        let handle = state.pending_promise_exceptions.remove(&key).unwrap();
            |VAR_DECL  |assign                                  |apply
                                                                 |ARG        |apply

1381        drop(state);
                |apply
                 |ARG|

1382    
1383        let context = self.global_context();
            |VAR_DECL   |assign              |apply

1384        let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

1385    
1386        let exception = v8::Local::new(scope, handle);
            |VAR_DECL     |assign         |apply
                                           |ARG|  |ARG |

1387        exception_to_err_result(scope, exception, true)
                                   |apply
                                    |ARG|  |ARG    |  |ARG

1388      }
          |}func

1389    
1390      // Respond using shared queue and optionally overflown response
1391      fn async_op_response(
          |FUNCTION

1392        &mut self,
            |PARAM  |

1393        maybe_overflown_response: Option<(OpId, Box<[u8]>)>,
            |PARAM                                            |

1394      ) -> Result<(), AnyError> {
                                    |func{

1395        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply

1396    
1397        let shared_queue_size = state_rc.borrow().shared.size();
            |VAR_DECL             |assign          |apply        |apply

1398    
1399        if shared_queue_size == 0 && maybe_overflown_response.is_none() {
            |IF                                                          |apply
                                                                            |if{

1400          return Ok(());
              |RETURN  |apply
                        |ARG
                        |tuple(
                         |)tuple

1401        }
            |}if

1402    
1403        // FIXME(bartlomieju): without check above this call would panic
1404        // because of lazy initialization in core.js. It seems this lazy initialization
1405        // hides unnecessary complexity.
1406        let js_recv_cb_handle = state_rc
            |VAR_DECL             |assign

1407          .borrow()
                     |apply

1408          .js_recv_cb
1409          .clone()
                    |apply

1410          .expect("Deno.core.recv has not been called.");
                     |apply
                      |ARG                                |

1411    
1412        let context = self.global_context();
            |VAR_DECL   |assign              |apply

1413        let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

1414        let context = scope.get_current_context();
            |VAR_DECL   |assign                    |apply

1415        let global: v8::Local<v8::Value> = context.global(scope).into();
            |VAR_DECL                        |assign         |apply
                                                              |ARG|      |apply

1416        let js_recv_cb = js_recv_cb_handle.get(scope);
            |VAR_DECL      |assign                |apply
                                                   |ARG|

1417    
1418        let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|

1419    
1420        if shared_queue_size > 0 {
            |IF                      |if{

1421          js_recv_cb.call(tc_scope, global, &[]);
                             |apply
                              |ARG   |  |ARG |  |ARG
                                                 |array{
                                                  |}array

1422          // The other side should have shifted off all the messages.
1423          let shared_queue_size = state_rc.borrow().shared.size();
              |VAR_DECL             |assign          |apply        |apply

1424          assert_eq!(shared_queue_size, 0);
              |MACRO()| |macro(){            |}macro()

1425        }
            |}if

1426    
1427        if let Some(overflown_response) = maybe_overflown_response {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG             |  |assign                    |if{

1428          let (op_id, buf) = overflown_response;
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM|T_ELEM
                             |)tuple
                               |assign

1429          let op_id: v8::Local<v8::Value> =
              |VAR_DECL                       |assign

1430            v8::Integer::new(tc_scope, op_id as i32).into();
                                |apply
                                 |ARG   |  |ARG       |      |apply

1431          let ui8: v8::Local<v8::Value> =
              |VAR_DECL                     |assign

1432            bindings::boxed_slice_to_uint8array(tc_scope, buf).into();
                                                   |apply
                                                    |ARG   |  |ARG     |apply

1433          js_recv_cb.call(tc_scope, global, &[op_id, ui8]);
                             |apply
                              |ARG   |  |ARG |  |ARG        |
                                                 |array{
                                                  |ARRAY_ELEM
                                                         |ARRAY_ELEM
                                                            |}array

1434        }
            |}if

1435    
1436        match tc_scope.exception() {
            |MATCH                  |apply
                                       |match{

1437          None => Ok(()),
              |CASE     |apply
                         |ARG
                         |tuple(
                          |)tuple

1438          Some(exception) => exception_to_err_result(tc_scope, exception, false),
              |CASE
              |STRUCT()
                   |ARG    |                            |apply
                                                         |ARG   |  |ARG    |  |ARG|

1439        }
            |}match

1440      }
          |}func

1441    
1442      fn drain_macrotasks(&mut self) -> Result<(), AnyError> {
          |FUNCTION           |PARAM  |                          |func{

1443        let js_macrotask_cb_handle =
            |VAR_DECL                  |assign

1444          match &Self::state(self.v8_isolate()).borrow().js_macrotask_cb {
              |MATCH            |apply
                                 |ARG            |
                                                |apply    |apply             |match{

1445            Some(handle) => handle.clone(),
                |CASE
                |STRUCT()
                     |ARG |                 |apply

1446            None => return Ok(()),
                |CASE   |RETURN  |apply
                                  |ARG
                                  |tuple(
                                   |)tuple

1447          };
              |}match

1448    
1449        let context = self.global_context();
            |VAR_DECL   |assign              |apply

1450        let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |

1451        let context = scope.get_current_context();
            |VAR_DECL   |assign                    |apply

1452        let global: v8::Local<v8::Value> = context.global(scope).into();
            |VAR_DECL                        |assign         |apply
                                                              |ARG|      |apply

1453        let js_macrotask_cb = js_macrotask_cb_handle.get(scope);
            |VAR_DECL           |assign                     |apply
                                                             |ARG|

1454    
1455        // Repeatedly invoke macrotask callback until it returns true (done),
1456        // such that ready microtasks would be automatically run before
1457        // next macrotask is processed.
1458        let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|

1459    
1460        loop {
            |LOOP|loop{

1461          let is_done = js_macrotask_cb.call(tc_scope, global, &[]);
              |VAR_DECL   |assign               |apply
                                                 |ARG   |  |ARG |  |ARG
                                                                    |array{
                                                                     |}array

1462    
1463          if let Some(exception) = tc_scope.exception() {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG    |  |assign             |apply
                                                            |if{

1464            return exception_to_err_result(tc_scope, exception, false);
                |RETURN                       |apply
                                               |ARG   |  |ARG    |  |ARG|

1465          }
              |}if

1466    
1467          let is_done = is_done.unwrap();
              |VAR_DECL   |assign         |apply

1468          if is_done.is_true() {
              |IF               |apply
                                   |if{

1469            break;
                |BREAK

1470          }
              |}if

1471        }
            |}loop

1472    
1473        Ok(())
              |apply
               |ARG
               |tuple(
                |)tuple

1474      }
          |}func

1475    }
        |}impl

1476    
1477    #[cfg(test)]
        |OUTER_ATTR|

1478    pub mod tests {
            |MODULE   |module{

1479      use super::*;
          |USE       |use_item

1480      use crate::modules::ModuleSourceFuture;
          |USE|USE_ITEM                        |

1481      use crate::BufVec;
          |USE|USE_ITEM   |

1482      use futures::future::lazy;
          |USE|USE_ITEM           |

1483      use futures::FutureExt;
          |USE|USE_ITEM        |

1484      use std::io;
          |USE|USE_ITEM

1485      use std::ops::FnOnce;
          |USE|USE_ITEM      |

1486      use std::rc::Rc;
          |USE|USE_ITEM |

1487      use std::sync::atomic::{AtomicUsize, Ordering};
          |USE                    |USE_ITEM |  |USE_ITEM

1488      use std::sync::Arc;
          |USE|USE_ITEM    |

1489    
1490      pub fn run_in_task<F>(f: F)
              |FUNCTION      |<t>
                                |PARAM

1491      where
1492        F: FnOnce(&mut Context) + Send + 'static,
1493      {
          |func{

1494        futures::executor::block_on(lazy(move |cx| f(cx)));
                                       |apply
                                        |ARG                |
                                            |apply
                                             |ARG          |
                                             |CLOSURE
                                                   |PARAM
                                                       |closure{
                                                       |return
                                                        |apply
                                                         |ARG
                                                           |}closure

1495      }
          |}func

1496    
1497      fn poll_until_ready(
          |FUNCTION

1498        runtime: &mut JsRuntime,
            |PARAM                |

1499        max_poll_count: usize,
            |PARAM              |

1500      ) -> Result<(), AnyError> {
                                    |func{

1501        let mut cx = Context::from_waker(futures::task::noop_waker_ref());
            |VAR_DECL  |assign              |apply
                                             |ARG                          |
                                                                          |apply

1502        for _ in 0..max_poll_count {
            |FOR                       |for{

1503          match runtime.poll_event_loop(&mut cx) {
              |MATCH                       |apply
                                            |ARG  |  |match{

1504            Poll::Pending => continue,
                |CASE

1505            Poll::Ready(val) => return val,
                |CASE
                |STRUCT()   |ARG    |RETURN

1506          }
              |}match

1507        }
            |}for

1508        panic!(
            |MACRO()
                  |macro(){

1509          "JsRuntime still not ready after polling {} times.",
1510          max_poll_count
1511        )
            |}macro()

1512      }
          |}func

1513    
1514      enum Mode {
          |ENUM     |enum{

1515        Async,
            |ENUM_ITEM

1516        AsyncUnref,
            |ENUM_ITEM

1517        AsyncZeroCopy(u8),
            |ENUM_ITEM  ||tuple(
                          |T_ELEM
                            |)tuple

1518        OverflowReqSync,
            |ENUM_ITEM    |

1519        OverflowResSync,
            |ENUM_ITEM    |

1520        OverflowReqAsync,
            |ENUM_ITEM     |

1521        OverflowResAsync,
            |ENUM_ITEM     |

1522      }
          |}enum

1523    
1524      struct TestState {
          |STRUCT          |struct{

1525        mode: Mode,
            |FIELD

1526        dispatch_count: Arc<AtomicUsize>,
            |FIELD       |

1527      }
          |}struct

1528    
1529      fn dispatch(op_state: Rc<RefCell<OpState>>, bufs: BufVec) -> Op {
          |FUNCTION   |PARAM                       |  |PARAM     |        |func{

1530        let op_state_ = op_state.borrow();
            |VAR_DECL     |assign          |apply

1531        let test_state = op_state_.borrow::<TestState>();
            |VAR_DECL      |assign              |T_ARG  | |apply

1532        test_state.dispatch_count.fetch_add(1, Ordering::Relaxed);
                                               |apply
                                                |arg
                                                   |ARG            |

1533        match test_state.mode {
            |MATCH                |match{

1534          Mode::Async => {
              |CASE          |inner{

1535            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()

1536            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()

1537            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()

1538            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply

1539            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply

1540          }
              |}inner

1541          Mode::AsyncUnref => {
              |CASE               |inner{

1542            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()

1543            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()

1544            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()

1545            let fut = async {
                |VAR_DECL
                        |assign |inner{

1546              // This future never finish.
1547              futures::future::pending::<()>().await;
                                             |T_ARG
                                                |apply

1548              vec![43u8].into_boxed_slice()
                  |MACRO()
                      |macro(){
                           |}macro()         |apply

1549            };
                |}inner

1550            Op::AsyncUnref(fut.boxed())
                              |apply
                               |ARG      |
                                        |apply

1551          }
              |}inner

1552          Mode::AsyncZeroCopy(count) => {
              |CASE
              |STRUCT()           |ARG|     |inner{

1553            assert_eq!(bufs.len(), count as usize);
                |MACRO()| |macro(){                  |}macro()

1554            bufs.iter().enumerate().for_each(|(idx, buf)| {
                         |apply      |apply     |apply
                                                 |ARG         |
                                                 |closure
                                                  |param
                                                  |tuple
                                                  |tuple(
                                                   |T_ELEM
                                                        |T_ELEM
                                                           |)tuple
                                                              |closure{
                                                              |return
                                                              |inner{

1555              assert_eq!(buf.len(), 1);
                  |MACRO()| |macro(){    |}macro()

1556              assert_eq!(idx, buf[0] as usize);
                  |MACRO()| |macro(){            |}macro()

1557            });
                |}inner
                |}closure

1558    
1559            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply

1560            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply

1561          }
              |}inner

1562          Mode::OverflowReqSync => {
              |CASE                    |inner{

1563            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()

1564            assert_eq!(bufs[0].len(), 100 * 1024 * 1024);
                |MACRO()| |macro(){                        |}macro()

1565            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply

1566            Op::Sync(buf)
                        |apply
                         |ARG

1567          }
              |}inner

1568          Mode::OverflowResSync => {
              |CASE                    |inner{

1569            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()

1570            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()

1571            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()

1572            let mut vec = vec![0u8; 100 * 1024 * 1024];
                |VAR_DECL   |assign
                              |MACRO()
                                  |macro(){              |}macro()

1573            vec[0] = 99;
                       |assign

1574            let buf = vec.into_boxed_slice();
                |VAR_DECL
                        |assign               |apply

1575            Op::Sync(buf)
                        |apply
                         |ARG

1576          }
              |}inner

1577          Mode::OverflowReqAsync => {
              |CASE                     |inner{

1578            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()

1579            assert_eq!(bufs[0].len(), 100 * 1024 * 1024);
                |MACRO()| |macro(){                        |}macro()

1580            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply

1581            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply

1582          }
              |}inner

1583          Mode::OverflowResAsync => {
              |CASE                     |inner{

1584            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()

1585            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()

1586            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()

1587            let mut vec = vec![0u8; 100 * 1024 * 1024];
                |VAR_DECL   |assign
                              |MACRO()
                                  |macro(){              |}macro()

1588            vec[0] = 4;
                       |assign

1589            let buf = vec.into_boxed_slice();
                |VAR_DECL
                        |assign               |apply

1590            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply

1591          }
              |}inner

1592        }
            |}match

1593      }
          |}func

1594    
1595      fn setup(mode: Mode) -> (JsRuntime, Arc<AtomicUsize>) {
          |FUNCTION|PARAM   |                                   |func{

1596        let dispatch_count = Arc::new(AtomicUsize::new(0));
            |VAR_DECL          |assign   |apply
                                          |ARG              |
                                                          |apply
                                                           |arg

1597        let mut runtime = JsRuntime::new(Default::default());
            |VAR_DECL       |assign         |apply
                                             |ARG             |
                                                             |apply

1598        let op_state = runtime.op_state();
            |VAR_DECL    |assign           |apply

1599        op_state.borrow_mut().put(TestState {
                               |apply|apply
                                      |ARG      |
                                      |STRUCT()

1600          mode,
              |ARG

1601          dispatch_count: dispatch_count.clone(),
              |ARG                                 |
                                                  |apply

1602        });
1603    
1604        runtime.register_op("test", dispatch);
                               |apply
                                |ARG |  |ARG   |

1605    
1606        runtime
1607          .execute(
                      |apply

1608            "setup.js",
                |ARG     |

1609            r#"
                |ARG|

1610            function assert(cond) {
1611              if (!cond) {
1612                throw Error("assert");
1613              }
1614            }
1615            "#,
1616          )
1617          .unwrap();
                     |apply

1618        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()

1619        (runtime, dispatch_count)
            |tuple(
             |T_ELEM  |T_ELEM      ||)tuple

1620      }
          |}func

1621    
1622      #[test]
          |OUTER_ATTR

1623      fn test_dispatch() {
          |FUNCTION          |func{

1624        let (mut runtime, dispatch_count) = setup(Mode::Async);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG      |

1625        runtime
1626          .execute(
                      |apply

1627            "filename.js",
                |ARG        |

1628            r#"
                |ARG|

1629            let control = new Uint8Array([42]);
1630            Deno.core.send(1, control);
1631            async function main() {
1632              Deno.core.send(1, control);
1633            }
1634            main();
1635            "#,
1636          )
1637          .unwrap();
                     |apply

1638        assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
            |MACRO()| |macro(){                                 |}macro()

1639      }
          |}func

1640    
1641      #[test]
          |OUTER_ATTR

1642      fn test_dispatch_no_zero_copy_buf() {
          |FUNCTION                           |func{

1643        let (mut runtime, dispatch_count) = setup(Mode::AsyncZeroCopy(0));
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                 |
                                                                         |apply
                                                                          |arg

1644        runtime
1645          .execute(
                      |apply

1646            "filename.js",
                |ARG        |

1647            r#"
                |ARG|

1648            Deno.core.send(1);
1649            "#,
1650          )
1651          .unwrap();
                     |apply

1652        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()

1653      }
          |}func

1654    
1655      #[test]
          |OUTER_ATTR

1656      fn test_dispatch_stack_zero_copy_bufs() {
          |FUNCTION                               |func{

1657        let (mut runtime, dispatch_count) = setup(Mode::AsyncZeroCopy(2));
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                 |
                                                                         |apply
                                                                          |arg

1658        runtime
1659          .execute(
                      |apply

1660            "filename.js",
                |ARG        |

1661            r#"
                |ARG|

1662            let zero_copy_a = new Uint8Array([0]);
1663            let zero_copy_b = new Uint8Array([1]);
1664            Deno.core.send(1, zero_copy_a, zero_copy_b);
1665            "#,
1666          )
1667          .unwrap();
                     |apply

1668        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()

1669      }
          |}func

1670    
1671      #[test]
          |OUTER_ATTR

1672      fn test_dispatch_heap_zero_copy_bufs() {
          |FUNCTION                              |func{

1673        let (mut runtime, dispatch_count) = setup(Mode::AsyncZeroCopy(5));
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                 |
                                                                         |apply
                                                                          |arg

1674        runtime.execute(
                           |apply

1675          "filename.js",
              |ARG        |

1676          r#"
              |ARG|

1677            let zero_copy_a = new Uint8Array([0]);
1678            let zero_copy_b = new Uint8Array([1]);
1679            let zero_copy_c = new Uint8Array([2]);
1680            let zero_copy_d = new Uint8Array([3]);
1681            let zero_copy_e = new Uint8Array([4]);
1682            Deno.core.send(1, zero_copy_a, zero_copy_b, zero_copy_c, zero_copy_d, zero_copy_e);
1683            "#,
1684        ).unwrap();
                    |apply

1685        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()

1686      }
          |}func

1687    
1688      #[test]
          |OUTER_ATTR

1689      fn test_poll_async_delayed_ops() {
          |FUNCTION                        |func{

1690        run_in_task(|cx| {
                       |apply
                        |ARG |
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{

1691          let (mut runtime, dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG      |

1692    
1693          runtime
1694            .execute(
                        |apply

1695              "setup2.js",
                  |ARG      |

1696              r#"
                  |ARG|

1697             let nrecv = 0;
1698             Deno.core.setAsyncHandler(1, (buf) => {
1699               nrecv++;
1700             });
1701             "#,
1702            )
1703            .unwrap();
                       |apply

1704          assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
              |MACRO()| |macro(){                                 |}macro()

1705          runtime
1706            .execute(
                        |apply

1707              "check1.js",
                  |ARG      |

1708              r#"
                  |ARG|

1709             assert(nrecv == 0);
1710             let control = new Uint8Array([42]);
1711             Deno.core.send(1, control);
1712             assert(nrecv == 0);
1713             "#,
1714            )
1715            .unwrap();
                       |apply

1716          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()

1717          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()

1718          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()

1719          runtime
1720            .execute(
                        |apply

1721              "check2.js",
                  |ARG      |

1722              r#"
                  |ARG|

1723             assert(nrecv == 1);
1724             Deno.core.send(1, control);
1725             assert(nrecv == 1);
1726             "#,
1727            )
1728            .unwrap();
                       |apply

1729          assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                                 |}macro()

1730          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()

1731          runtime.execute("check3.js", "assert(nrecv == 2)").unwrap();
                             |apply
                              |ARG      |  |ARG               |        |apply

1732          assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                                 |}macro()

1733          // We are idle, so the next poll should be the last.
1734          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()

1735        });
            |}inner
            |}closure

1736      }
          |}func

1737    
1738      #[test]
          |OUTER_ATTR

1739      fn test_poll_async_optional_ops() {
          |FUNCTION                         |func{

1740        run_in_task(|cx| {
                       |apply
                        |ARG |
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{

1741          let (mut runtime, dispatch_count) = setup(Mode::AsyncUnref);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG           |

1742          runtime
1743            .execute(
                        |apply

1744              "check1.js",
                  |ARG      |

1745              r#"
                  |ARG|

1746              Deno.core.setAsyncHandler(1, (buf) => {
1747                // This handler will never be called
1748                assert(false);
1749              });
1750              let control = new Uint8Array([42]);
1751              Deno.core.send(1, control);
1752            "#,
1753            )
1754            .unwrap();
                       |apply

1755          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()

1756          // The above op never finish, but runtime can finish
1757          // because the op is an unreffed async op.
1758          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()

1759        })
            |}inner
            |}closure

1760      }
          |}func

1761    
1762      #[test]
          |OUTER_ATTR

1763      fn terminate_execution() {
          |FUNCTION                |func{

1764        let (mut isolate, _dispatch_count) = setup(Mode::Async);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM       ||)tuple
                                               |assign|apply
                                                       |ARG      |

1765        // TODO(piscisaureus): in rusty_v8, the `thread_safe_handle()` method
1766        // should not require a mutable reference to `struct rusty_v8::Isolate`.
1767        let v8_isolate_handle = isolate.v8_isolate().thread_safe_handle();
            |VAR_DECL             |assign             |apply               |apply

1768    
1769        let terminator_thread = std::thread::spawn(move || {
            |VAR_DECL             |assign             |apply
                                                       |ARG    |
                                                       |CLOSURE|closure{
                                                               |return
                                                               |inner{

1770          // allow deno to boot and run
1771          std::thread::sleep(std::time::Duration::from_millis(100));
                                |apply
                                 |ARG                                |
                                                                 |apply
                                                                  |ARG

1772    
1773          // terminate execution
1774          let ok = v8_isolate_handle.terminate_execution();
              |VAR_DECL
                     |assign                                |apply

1775          assert!(ok);
              |MACRO()
                     |macro(){
                        |}macro()

1776        });
            |}inner
            |}closure

1777    
1778        // Rn an infinite loop, which should be terminated.
1779        match isolate.execute("infinite_loop.js", "for(;;) {}") {
            |MATCH               |apply
                                  |ARG             |  |ARG       |  |match{

1780          Ok(_) => panic!("execution should be terminated"),
              |CASE
              |STRUCT()
                 |arg  |MACRO()
                             |macro(){                        |}macro()

1781          Err(e) => {
              |CASE
              |STRUCT()
                  |arg  |inner{

1782            assert_eq!(e.to_string(), "Uncaught Error: execution terminated")
                |MACRO()| |macro(){                                             |}macro()

1783          }
              |}inner

1784        };
            |}match

1785    
1786        // Cancel the execution-terminating exception in order to allow script
1787        // execution again.
1788        // TODO(piscisaureus): in rusty_v8, `cancel_terminate_execution()` should
1789        // also be implemented on `struct Isolate`.
1790        let ok = isolate
            |VAR_DECL
                   |assign

1791          .v8_isolate()
                         |apply

1792          .thread_safe_handle()
                                 |apply

1793          .cancel_terminate_execution();
                                         |apply

1794        assert!(ok);
            |MACRO()
                   |macro(){
                      |}macro()

1795    
1796        // Verify that the isolate usable again.
1797        isolate
1798          .execute("simple.js", "1 + 1")
                      |apply
                       |ARG      |  |ARG  |

1799          .expect("execution should be possible again");
                     |apply
                      |ARG                               |

1800    
1801        terminator_thread.join().unwrap();
                                  |apply   |apply

1802      }
          |}func

1803    
1804      #[test]
          |OUTER_ATTR

1805      fn dangling_shared_isolate() {
          |FUNCTION                    |func{

1806        let v8_isolate_handle = {
            |VAR_DECL             |assign
                                    |inner{

1807          // isolate is dropped at the end of this block
1808          let (mut runtime, _dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG      |

1809          // TODO(piscisaureus): in rusty_v8, the `thread_safe_handle()` method
1810          // should not require a mutable reference to `struct rusty_v8::Isolate`.
1811          runtime.v8_isolate().thread_safe_handle()
                                |apply               |apply

1812        };
            |}inner

1813    
1814        // this should not SEGFAULT
1815        v8_isolate_handle.terminate_execution();
                                                 |apply

1816      }
          |}func

1817    
1818      #[test]
          |OUTER_ATTR

1819      fn overflow_req_sync() {
          |FUNCTION              |func{

1820        let (mut runtime, dispatch_count) = setup(Mode::OverflowReqSync);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                |

1821        runtime
1822          .execute(
                      |apply

1823            "overflow_req_sync.js",
                |ARG                 |

1824            r#"
                |ARG|

1825            let asyncRecv = 0;
1826            Deno.core.setAsyncHandler(1, (buf) => { asyncRecv++ });
1827            // Large message that will overflow the shared space.
1828            let control = new Uint8Array(100 * 1024 * 1024);
1829            let response = Deno.core.dispatch(1, control);
1830            assert(response instanceof Uint8Array);
1831            assert(response.length == 1);
1832            assert(response[0] == 43);
1833            assert(asyncRecv == 0);
1834            "#,
1835          )
1836          .unwrap();
                     |apply

1837        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()

1838      }
          |}func

1839    
1840      #[test]
          |OUTER_ATTR

1841      fn overflow_res_sync() {
          |FUNCTION              |func{

1842        // TODO(ry) This test is quite slow due to memcpy-ing 100MB into JS. We
1843        // should optimize this.
1844        let (mut runtime, dispatch_count) = setup(Mode::OverflowResSync);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                |

1845        runtime
1846          .execute(
                      |apply

1847            "overflow_res_sync.js",
                |ARG                 |

1848            r#"
                |ARG|

1849            let asyncRecv = 0;
1850            Deno.core.setAsyncHandler(1, (buf) => { asyncRecv++ });
1851            // Large message that will overflow the shared space.
1852            let control = new Uint8Array([42]);
1853            let response = Deno.core.dispatch(1, control);
1854            assert(response instanceof Uint8Array);
1855            assert(response.length == 100 * 1024 * 1024);
1856            assert(response[0] == 99);
1857            assert(asyncRecv == 0);
1858            "#,
1859          )
1860          .unwrap();
                     |apply

1861        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()

1862      }
          |}func

1863    
1864      #[test]
          |OUTER_ATTR

1865      fn overflow_req_async() {
          |FUNCTION               |func{

1866        run_in_task(|cx| {
                       |apply
                        |ARG |
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{

1867          let (mut runtime, dispatch_count) = setup(Mode::OverflowReqAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG                 |

1868          runtime
1869            .execute(
                        |apply

1870              "overflow_req_async.js",
                  |ARG                  |

1871              r#"
                  |ARG|

1872             let asyncRecv = 0;
1873             Deno.core.setAsyncHandler(1, (buf) => {
1874               assert(buf.byteLength === 1);
1875               assert(buf[0] === 43);
1876               asyncRecv++;
1877             });
1878             // Large message that will overflow the shared space.
1879             let control = new Uint8Array(100 * 1024 * 1024);
1880             let response = Deno.core.dispatch(1, control);
1881             // Async messages always have null response.
1882             assert(response == null);
1883             assert(asyncRecv == 0);
1884             "#,
1885            )
1886            .unwrap();
                       |apply

1887          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()

1888          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()

1889          runtime
1890            .execute("check.js", "assert(asyncRecv == 1);")
                        |apply
                         |ARG     |  |ARG                    |

1891            .unwrap();
                       |apply

1892        });
            |}inner
            |}closure

1893      }
          |}func

1894    
1895      #[test]
          |OUTER_ATTR

1896      fn overflow_res_async() {
          |FUNCTION               |func{

1897        run_in_task(|_cx| {
                       |apply
                        |ARG  |
                        |closure
                         |PARAM
                              |closure{
                              |return
                              |inner{

1898          // TODO(ry) This test is quite slow due to memcpy-ing 100MB into JS. We
1899          // should optimize this.
1900          let (mut runtime, dispatch_count) = setup(Mode::OverflowResAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG                 |

1901          runtime
1902            .execute(
                        |apply

1903              "overflow_res_async.js",
                  |ARG                  |

1904              r#"
                  |ARG|

1905             let asyncRecv = 0;
1906             Deno.core.setAsyncHandler(1, (buf) => {
1907               assert(buf.byteLength === 100 * 1024 * 1024);
1908               assert(buf[0] === 4);
1909               asyncRecv++;
1910             });
1911             // Large message that will overflow the shared space.
1912             let control = new Uint8Array([42]);
1913             let response = Deno.core.dispatch(1, control);
1914             assert(response == null);
1915             assert(asyncRecv == 0);
1916             "#,
1917            )
1918            .unwrap();
                       |apply

1919          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()

1920          poll_until_ready(&mut runtime, 3).unwrap();
                              |apply
                               |ARG       |  |arg     |apply

1921          runtime
1922            .execute("check.js", "assert(asyncRecv == 1);")
                        |apply
                         |ARG     |  |ARG                    |

1923            .unwrap();
                       |apply

1924        });
            |}inner
            |}closure

1925      }
          |}func

1926    
1927      #[test]
          |OUTER_ATTR

1928      fn overflow_res_multiple_dispatch_async() {
          |FUNCTION                                 |func{

1929        // TODO(ry) This test is quite slow due to memcpy-ing 100MB into JS. We
1930        // should optimize this.
1931        run_in_task(|_cx| {
                       |apply
                        |ARG  |
                        |closure
                         |PARAM
                              |closure{
                              |return
                              |inner{

1932          let (mut runtime, dispatch_count) = setup(Mode::OverflowResAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG                 |

1933          runtime
1934            .execute(
                        |apply

1935              "overflow_res_multiple_dispatch_async.js",
                  |ARG                                    |

1936              r#"
                  |ARG|

1937             let asyncRecv = 0;
1938             Deno.core.setAsyncHandler(1, (buf) => {
1939               assert(buf.byteLength === 100 * 1024 * 1024);
1940               assert(buf[0] === 4);
1941               asyncRecv++;
1942             });
1943             // Large message that will overflow the shared space.
1944             let control = new Uint8Array([42]);
1945             let response = Deno.core.dispatch(1, control);
1946             assert(response == null);
1947             assert(asyncRecv == 0);
1948             // Dispatch another message to verify that pending ops
1949             // are done even if shared space overflows
1950             Deno.core.dispatch(1, control);
1951             "#,
1952            )
1953            .unwrap();
                       |apply

1954          assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                                 |}macro()

1955          poll_until_ready(&mut runtime, 3).unwrap();
                              |apply
                               |ARG       |  |arg     |apply

1956          runtime
1957            .execute("check.js", "assert(asyncRecv == 2);")
                        |apply
                         |ARG     |  |ARG                    |

1958            .unwrap();
                       |apply

1959        });
            |}inner
            |}closure

1960      }
          |}func

1961    
1962      #[test]
          |OUTER_ATTR

1963      fn test_pre_dispatch() {
          |FUNCTION              |func{

1964        run_in_task(|mut cx| {
                       |apply
                        |ARG     |
                        |closure
                         |PARAM  |closure{
                                 |return
                                 |inner{

1965          let (mut runtime, _dispatch_count) = setup(Mode::OverflowResAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG                 |

1966          runtime
1967            .execute(
                        |apply

1968              "bad_op_id.js",
                  |ARG         |

1969              r#"
                  |ARG|

1970              let thrown;
1971              try {
1972                Deno.core.dispatch(100);
1973              } catch (e) {
1974                thrown = e;
1975              }
1976              assert(String(thrown) === "TypeError: Unknown op id: 100");
1977             "#,
1978            )
1979            .unwrap();
                       |apply

1980          if let Poll::Ready(Err(_)) = runtime.poll_event_loop(&mut cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG |
                                 |STRUCT()
                                     |arg|assign                  |apply
                                                                   |ARG  |  |if{

1981            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()

1982          }
              |}if

1983        });
            |}inner
            |}closure

1984      }
          |}func

1985    
1986      #[test]
          |OUTER_ATTR

1987      fn core_test_js() {
          |FUNCTION         |func{

1988        run_in_task(|mut cx| {
                       |apply
                        |ARG     |
                        |closure
                         |PARAM  |closure{
                                 |return
                                 |inner{

1989          let (mut runtime, _dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG      |

1990          runtime
1991            .execute("core_test.js", include_str!("core_test.js"))
                        |apply
                         |ARG         |  |ARG                       |
                                         |MACRO()  | |macro(){      |}macro()

1992            .unwrap();
                       |apply

1993          if let Poll::Ready(Err(_)) = runtime.poll_event_loop(&mut cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG |
                                 |STRUCT()
                                     |arg|assign                  |apply
                                                                   |ARG  |  |if{

1994            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()

1995          }
              |}if

1996        });
            |}inner
            |}closure

1997      }
          |}func

1998    
1999      #[test]
          |OUTER_ATTR

2000      fn syntax_error() {
          |FUNCTION         |func{

2001        let mut runtime = JsRuntime::new(Default::default());
            |VAR_DECL       |assign         |apply
                                             |ARG             |
                                                             |apply

2002        let src = "hocuspocus(";
            |VAR_DECL
                    |assign

2003        let r = runtime.execute("i.js", src);
            |VAR_DECL
                  |assign          |apply
                                    |ARG |  |ARG

2004        let e = r.unwrap_err();
            |VAR_DECL
                  |assign       |apply

2005        let js_error = e.downcast::<JsError>().unwrap();
            |VAR_DECL    |assign        |T_ARG| |apply   |apply

2006        assert_eq!(js_error.end_column, Some(11));
            |MACRO()| |macro(){                     |}macro()

2007      }
          |}func

2008    
2009      #[test]
          |OUTER_ATTR

2010      fn test_encode_decode() {
          |FUNCTION               |func{

2011        run_in_task(|mut cx| {
                       |apply
                        |ARG     |
                        |closure
                         |PARAM  |closure{
                                 |return
                                 |inner{

2012          let (mut runtime, _dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG      |

2013          runtime
2014            .execute(
                        |apply

2015              "encode_decode_test.js",
                  |ARG                  |

2016              include_str!("encode_decode_test.js"),
                  |ARG                                |
                  |MACRO()  | |macro(){               |}macro()

2017            )
2018            .unwrap();
                       |apply

2019          if let Poll::Ready(Err(_)) = runtime.poll_event_loop(&mut cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG |
                                 |STRUCT()
                                     |arg|assign                  |apply
                                                                   |ARG  |  |if{

2020            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()

2021          }
              |}if

2022        });
            |}inner
            |}closure

2023      }
          |}func

2024    
2025      #[test]
          |OUTER_ATTR

2026      fn will_snapshot() {
          |FUNCTION          |func{

2027        let snapshot = {
            |VAR_DECL    |assign
                           |inner{

2028          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG           |
                                               |STRUCT()    |

2029            will_snapshot: true,
                |ARG              |

2030            ..Default::default()
                                  |apply

2031          });
2032          runtime.execute("a.js", "a = 1 + 2").unwrap();
                             |apply
                              |ARG |  |ARG      |        |apply

2033          runtime.snapshot()
                              |apply

2034        };
            |}inner

2035    
2036        let snapshot = Snapshot::JustCreated(snapshot);
            |VAR_DECL    |assign                |apply
                                                 |ARG   |

2037        let mut runtime2 = JsRuntime::new(RuntimeOptions {
            |VAR_DECL        |assign         |apply
                                              |ARG           |
                                              |STRUCT()    |

2038          startup_snapshot: Some(snapshot),
              |ARG                           |
                                    |apply
                                     |ARG   |

2039          ..Default::default()
                                |apply

2040        });
2041        runtime2
2042          .execute("check.js", "if (a != 3) throw Error('x')")
                      |apply
                       |ARG     |  |ARG                         |

2043          .unwrap();
                     |apply

2044      }
          |}func

2045    
2046      #[test]
          |OUTER_ATTR

2047      fn test_from_boxed_snapshot() {
          |FUNCTION                     |func{

2048        let snapshot = {
            |VAR_DECL    |assign
                           |inner{

2049          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG           |
                                               |STRUCT()    |

2050            will_snapshot: true,
                |ARG              |

2051            ..Default::default()
                                  |apply

2052          });
2053          runtime.execute("a.js", "a = 1 + 2").unwrap();
                             |apply
                              |ARG |  |ARG      |        |apply

2054          let snap: &[u8] = &*runtime.snapshot();
              |VAR_DECL       |assign             |apply

2055          Vec::from(snap).into_boxed_slice()
                       |apply
                        |ARG                  |apply

2056        };
            |}inner

2057    
2058        let snapshot = Snapshot::Boxed(snapshot);
            |VAR_DECL    |assign          |apply
                                           |ARG   |

2059        let mut runtime2 = JsRuntime::new(RuntimeOptions {
            |VAR_DECL        |assign         |apply
                                              |ARG           |
                                              |STRUCT()    |

2060          startup_snapshot: Some(snapshot),
              |ARG                           |
                                    |apply
                                     |ARG   |

2061          ..Default::default()
                                |apply

2062        });
2063        runtime2
2064          .execute("check.js", "if (a != 3) throw Error('x')")
                      |apply
                       |ARG     |  |ARG                         |

2065          .unwrap();
                     |apply

2066      }
          |}func

2067    
2068      #[test]
          |OUTER_ATTR

2069      fn test_heap_limits() {
          |FUNCTION             |func{

2070        let create_params = v8::Isolate::create_params().heap_limits(0, 20 * 1024);
            |VAR_DECL         |assign                     |apply        |apply
                                                                         |arg
                                                                            |ARG    |

2071        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG           |
                                             |STRUCT()    |

2072          create_params: Some(create_params),
              |ARG                             |
                                 |apply
                                  |ARG        |

2073          ..Default::default()
                                |apply

2074        });
2075        let cb_handle = runtime.v8_isolate().thread_safe_handle();
            |VAR_DECL     |assign             |apply               |apply

2076    
2077        let callback_invoke_count = Rc::new(AtomicUsize::default());
            |VAR_DECL                 |assign  |apply
                                                |ARG                 |
                                                                    |apply

2078        let inner_invoke_count = Rc::clone(&callback_invoke_count);
            |VAR_DECL              |assign    |apply
                                               |ARG                 |

2079    
2080        runtime.add_near_heap_limit_callback(
                                                |apply

2081          move |current_limit, _initial_limit| {
              |ARG                                 |
              |CLOSURE
                    |PARAM      |  |PARAM       |  |closure{
                                                   |return
                                                   |inner{

2082            inner_invoke_count.fetch_add(1, Ordering::SeqCst);
                                            |apply
                                             |arg
                                                |ARG           |

2083            cb_handle.terminate_execution();
                                             |apply

2084            current_limit * 2
2085          },
              |}inner
              |}closure

2086        );
2087        let err = runtime
            |VAR_DECL
                    |assign

2088          .execute(
                      |apply

2089            "script name",
                |ARG        |

2090            r#"let s = ""; while(true) { s += "Hello"; }"#,
                |ARG                                         |

2091          )
2092          .expect_err("script should fail");
                         |apply
                          |ARG               |

2093        assert_eq!(
            |MACRO()| |macro(){

2094          "Uncaught Error: execution terminated",
2095          err.downcast::<JsError>().unwrap().message
2096        );
            |}macro()

2097        assert!(callback_invoke_count.load(Ordering::SeqCst) > 0)
            |MACRO()
                   |macro(){                                        |}macro()

2098      }
          |}func

2099    
2100      #[test]
          |OUTER_ATTR

2101      fn test_heap_limit_cb_remove() {
          |FUNCTION                      |func{

2102        let mut runtime = JsRuntime::new(Default::default());
            |VAR_DECL       |assign         |apply
                                             |ARG             |
                                                             |apply

2103    
2104        runtime.add_near_heap_limit_callback(|current_limit, _initial_limit| {
                                                |apply
                                                 |ARG                            |
                                                 |closure
                                                  |PARAM      |  |PARAM       |  |closure{
                                                                                 |return
                                                                                 |inner{

2105          current_limit * 2
2106        });
            |}inner
            |}closure

2107        runtime.remove_near_heap_limit_callback(20 * 1024);
                                                   |apply
                                                    |ARG    |

2108        assert!(runtime.allocations.near_heap_limit_callback_data.is_none());
            |MACRO()
                   |macro(){                                                   |}macro()

2109      }
          |}func

2110    
2111      #[test]
          |OUTER_ATTR

2112      fn test_heap_limit_cb_multiple() {
          |FUNCTION                        |func{

2113        let create_params = v8::Isolate::create_params().heap_limits(0, 20 * 1024);
            |VAR_DECL         |assign                     |apply        |apply
                                                                         |arg
                                                                            |ARG    |

2114        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG           |
                                             |STRUCT()    |

2115          create_params: Some(create_params),
              |ARG                             |
                                 |apply
                                  |ARG        |

2116          ..Default::default()
                                |apply

2117        });
2118        let cb_handle = runtime.v8_isolate().thread_safe_handle();
            |VAR_DECL     |assign             |apply               |apply

2119    
2120        let callback_invoke_count_first = Rc::new(AtomicUsize::default());
            |VAR_DECL                       |assign  |apply
                                                      |ARG                 |
                                                                          |apply

2121        let inner_invoke_count_first = Rc::clone(&callback_invoke_count_first);
            |VAR_DECL                    |assign    |apply
                                                     |ARG                       |

2122        runtime.add_near_heap_limit_callback(
                                                |apply

2123          move |current_limit, _initial_limit| {
              |ARG                                 |
              |CLOSURE
                    |PARAM      |  |PARAM       |  |closure{
                                                   |return
                                                   |inner{

2124            inner_invoke_count_first.fetch_add(1, Ordering::SeqCst);
                                                  |apply
                                                   |arg
                                                      |ARG           |

2125            current_limit * 2
2126          },
              |}inner
              |}closure

2127        );
2128    
2129        let callback_invoke_count_second = Rc::new(AtomicUsize::default());
            |VAR_DECL                        |assign  |apply
                                                       |ARG                 |
                                                                           |apply

2130        let inner_invoke_count_second = Rc::clone(&callback_invoke_count_second);
            |VAR_DECL                     |assign    |apply
                                                      |ARG                        |

2131        runtime.add_near_heap_limit_callback(
                                                |apply

2132          move |current_limit, _initial_limit| {
              |ARG                                 |
              |CLOSURE
                    |PARAM      |  |PARAM       |  |closure{
                                                   |return
                                                   |inner{

2133            inner_invoke_count_second.fetch_add(1, Ordering::SeqCst);
                                                   |apply
                                                    |arg
                                                       |ARG           |

2134            cb_handle.terminate_execution();
                                             |apply

2135            current_limit * 2
2136          },
              |}inner
              |}closure

2137        );
2138    
2139        let err = runtime
            |VAR_DECL
                    |assign

2140          .execute(
                      |apply

2141            "script name",
                |ARG        |

2142            r#"let s = ""; while(true) { s += "Hello"; }"#,
                |ARG                                         |

2143          )
2144          .expect_err("script should fail");
                         |apply
                          |ARG               |

2145        assert_eq!(
            |MACRO()| |macro(){

2146          "Uncaught Error: execution terminated",
2147          err.downcast::<JsError>().unwrap().message
2148        );
            |}macro()

2149        assert_eq!(0, callback_invoke_count_first.load(Ordering::SeqCst));
            |MACRO()| |macro(){                                             |}macro()

2150        assert!(callback_invoke_count_second.load(Ordering::SeqCst) > 0);
            |MACRO()
                   |macro(){                                               |}macro()

2151      }
          |}func

2152    
2153      #[test]
          |OUTER_ATTR

2154      fn test_mods() {
          |FUNCTION      |func{

2155        #[derive(Default)]
            |OUTER_ATTR      |

2156        struct ModsLoader {
            |STRUCT           |struct{

2157          pub count: Arc<AtomicUsize>,
              |FIELD

2158        }
            |}struct

2159    
2160        impl ModuleLoader for ModsLoader {
            |IMPL                            |impl{

2161          fn resolve(
              |FUNCTION

2162            &self,
                |PARAM

2163            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |

2164            specifier: &str,
                |PARAM        |

2165            referrer: &str,
                |PARAM       |

2166            _is_main: bool,
                |PARAM       |

2167          ) -> Result<ModuleSpecifier, AnyError> {
                                                     |func{

2168            self.count.fetch_add(1, Ordering::Relaxed);
                                    |apply
                                     |arg
                                        |ARG            |

2169            assert_eq!(specifier, "./b.js");
                |MACRO()| |macro(){           |}macro()

2170            assert_eq!(referrer, "file:///a.js");
                |MACRO()| |macro(){                |}macro()

2171            let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
                |VAR_DECL
                      |assign                          |apply
                                                        |ARG    |  |ARG   |        |apply

2172            Ok(s)
                  |apply
                   |arg

2173          }
              |}func

2174    
2175          fn load(
              |FUNCTION

2176            &self,
                |PARAM

2177            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |

2178            _module_specifier: &ModuleSpecifier,
                |PARAM                            |

2179            _maybe_referrer: Option<ModuleSpecifier>,
                |PARAM                                 |

2180            _is_dyn_import: bool,
                |PARAM             |

2181          ) -> Pin<Box<ModuleSourceFuture>> {
                                                |func{

2182            unreachable!()
                |MACRO()  | |macro(){
                             |}macro()

2183          }
              |}func

2184        }
            |}impl

2185    
2186        let loader = Rc::new(ModsLoader::default());
            |VAR_DECL  |assign  |apply
                                 |ARG                |
                                                    |apply

2187    
2188        let resolve_count = loader.count.clone();
            |VAR_DECL         |assign             |apply

2189        let dispatch_count = Arc::new(AtomicUsize::new(0));
            |VAR_DECL          |assign   |apply
                                          |ARG              |
                                                          |apply
                                                           |arg

2190        let dispatch_count_ = dispatch_count.clone();
            |VAR_DECL           |assign               |apply

2191    
2192        let dispatcher = move |_state: Rc<RefCell<OpState>>, bufs: BufVec| -> Op {
            |VAR_DECL      |assign
                             |CLOSURE
                                   |PARAM                        |PARAM              |closure{

2193          dispatch_count_.fetch_add(1, Ordering::Relaxed);
                                       |apply
                                        |arg
                                           |ARG            |

2194          assert_eq!(bufs.len(), 1);
              |MACRO()| |macro(){     |}macro()

2195          assert_eq!(bufs[0].len(), 1);
              |MACRO()| |macro(){        |}macro()

2196          assert_eq!(bufs[0][0], 42);
              |MACRO()| |macro(){      |}macro()

2197          let buf = [43u8, 0, 0, 0][..].into();
              |VAR_DECL
                      |assign
                        |array{
                         |ARRAY_ELEM
                               |array_elem
                                  |array_elem
                                     |array_elem
                                      |}array   |apply

2198          Op::Async(futures::future::ready(buf).boxed())
                       |apply
                        |ARG                              |
                                              |apply
                                               |ARG      |apply

2199        };
            |}closure

2200    
2201        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG           |
                                             |STRUCT()    |

2202          module_loader: Some(loader),
              |ARG                      |
                                 |apply
                                  |ARG |

2203          ..Default::default()
                                |apply

2204        });
2205        runtime.register_op("test", dispatcher);
                               |apply
                                |ARG |  |ARG     |

2206    
2207        runtime
2208          .execute(
                      |apply

2209            "setup.js",
                |ARG     |

2210            r#"
                |ARG|

2211            function assert(cond) {
2212              if (!cond) {
2213                throw Error("assert");
2214              }
2215            }
2216            "#,
2217          )
2218          .unwrap();
                     |apply

2219    
2220        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()

2221    
2222        let specifier_a = "file:///a.js".to_string();
            |VAR_DECL       |assign                   |apply

2223        let mod_a = runtime
            |VAR_DECL |assign

2224          .mod_new(
                      |apply

2225            true,
                |ARG

2226            &specifier_a,
                |ARG       |

2227            r#"
                |ARG|

2228            import { b } from './b.js'
2229            if (b() != 'b') throw Error();
2230            let control = new Uint8Array([42]);
2231            Deno.core.send(1, control);
2232          "#,
2233          )
2234          .unwrap();
                     |apply

2235        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()

2236    
2237        let state_rc = JsRuntime::state(runtime.v8_isolate());
            |VAR_DECL    |assign           |apply
                                            |ARG               |
                                                              |apply

2238        {
            |inner{

2239          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

2240          let imports = state.modules.get_children(mod_a);
              |VAR_DECL   |assign                     |apply
                                                       |ARG|

2241          assert_eq!(
              |MACRO()| |macro(){

2242            imports,
2243            Some(&vec![ModuleSpecifier::resolve_url("file:///b.js").unwrap()])
2244          );
              |}macro()

2245        }
            |}inner

2246        let mod_b = runtime
            |VAR_DECL |assign

2247          .mod_new(false, "file:///b.js", "export function b() { return 'b' }")
                      |apply
                       |ARG|  |ARG         |  |ARG                               |

2248          .unwrap();
                     |apply

2249        {
            |inner{

2250          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply

2251          let imports = state.modules.get_children(mod_b).unwrap();
              |VAR_DECL   |assign                     |apply
                                                       |ARG|        |apply

2252          assert_eq!(imports.len(), 0);
              |MACRO()| |macro(){        |}macro()

2253        }
            |}inner

2254    
2255        runtime.mod_instantiate(mod_b).unwrap();
                                   |apply
                                    |ARG|        |apply

2256        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()

2257        assert_eq!(resolve_count.load(Ordering::SeqCst), 1);
            |MACRO()| |macro(){                               |}macro()

2258    
2259        runtime.mod_instantiate(mod_a).unwrap();
                                   |apply
                                    |ARG|        |apply

2260        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()

2261    
2262        runtime.mod_evaluate_inner(mod_a);
                                      |apply
                                       |ARG|

2263        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()

2264      }
          |}func

2265    
2266      #[test]
          |OUTER_ATTR

2267      fn dyn_import_err() {
          |FUNCTION           |func{

2268        #[derive(Clone, Default)]
            |OUTER_ATTR             |

2269        struct DynImportErrLoader {
            |STRUCT                   |struct{

2270          pub count: Arc<AtomicUsize>,
              |FIELD

2271        }
            |}struct

2272    
2273        impl ModuleLoader for DynImportErrLoader {
            |IMPL                                    |impl{

2274          fn resolve(
              |FUNCTION

2275            &self,
                |PARAM

2276            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |

2277            specifier: &str,
                |PARAM        |

2278            referrer: &str,
                |PARAM       |

2279            _is_main: bool,
                |PARAM       |

2280          ) -> Result<ModuleSpecifier, AnyError> {
                                                     |func{

2281            self.count.fetch_add(1, Ordering::Relaxed);
                                    |apply
                                     |arg
                                        |ARG            |

2282            assert_eq!(specifier, "/foo.js");
                |MACRO()| |macro(){            |}macro()

2283            assert_eq!(referrer, "file:///dyn_import2.js");
                |MACRO()| |macro(){                          |}macro()

2284            let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
                |VAR_DECL
                      |assign                          |apply
                                                        |ARG    |  |ARG   |        |apply

2285            Ok(s)
                  |apply
                   |arg

2286          }
              |}func

2287    
2288          fn load(
              |FUNCTION

2289            &self,
                |PARAM

2290            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |

2291            _module_specifier: &ModuleSpecifier,
                |PARAM                            |

2292            _maybe_referrer: Option<ModuleSpecifier>,
                |PARAM                                 |

2293            _is_dyn_import: bool,
                |PARAM             |

2294          ) -> Pin<Box<ModuleSourceFuture>> {
                                                |func{

2295            async { Err(io::Error::from(io::ErrorKind::NotFound).into()) }.boxed()
                      |inner{
                           |apply
                            |ARG                                          |
                                           |apply
                                            |ARG                  |      |apply
                                                                             |}inner|apply

2296          }
              |}func

2297        }
            |}impl

2298    
2299        // Test an erroneous dynamic import where the specified module isn't found.
2300        run_in_task(|cx| {
                       |apply
                        |ARG |
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{

2301          let loader = Rc::new(DynImportErrLoader::default());
              |VAR_DECL  |assign  |apply
                                   |ARG                        |
                                                              |apply

2302          let count = loader.count.clone();
              |VAR_DECL |assign             |apply

2303          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG           |
                                               |STRUCT()    |

2304            module_loader: Some(loader),
                |ARG                      |
                                   |apply
                                    |ARG |

2305            ..Default::default()
                                  |apply

2306          });
2307    
2308          runtime
2309            .execute(
                        |apply

2310              "file:///dyn_import2.js",
                  |ARG                   |

2311              r#"
                  |ARG|

2312            (async () => {
2313              await import("/foo.js");
2314            })();
2315            "#,
2316            )
2317            .unwrap();
                       |apply

2318    
2319          assert_eq!(count.load(Ordering::Relaxed), 0);
              |MACRO()| |macro(){                        |}macro()

2320          // We should get an error here.
2321          let result = runtime.poll_event_loop(cx);
              |VAR_DECL  |assign                  |apply
                                                   |ARG

2322          if let Poll::Ready(Ok(_)) = result {
              |IF|VAR_DECL
                     |STRUCT()   |ARG|
                                 |STRUCT()
                                    |arg|assign  |if{

2323            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()

2324          }
              |}if

2325          assert_eq!(count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                        |}macro()

2326        })
            |}inner
            |}closure

2327      }
          |}func

2328    
2329      #[derive(Clone, Default)]
          |OUTER_ATTR             |

2330      struct DynImportOkLoader {
          |STRUCT                  |struct{

2331        pub prepare_load_count: Arc<AtomicUsize>,
            |FIELD

2332        pub resolve_count: Arc<AtomicUsize>,
            |FIELD

2333        pub load_count: Arc<AtomicUsize>,
            |FIELD

2334      }
          |}struct

2335    
2336      impl ModuleLoader for DynImportOkLoader {
          |IMPL                                   |impl{

2337        fn resolve(
            |FUNCTION

2338          &self,
              |PARAM

2339          _op_state: Rc<RefCell<OpState>>,
              |PARAM                        |

2340          specifier: &str,
              |PARAM        |

2341          referrer: &str,
              |PARAM       |

2342          _is_main: bool,
              |PARAM       |

2343        ) -> Result<ModuleSpecifier, AnyError> {
                                                   |func{

2344          let c = self.resolve_count.fetch_add(1, Ordering::Relaxed);
              |VAR_DECL
                    |assign                       |apply
                                                   |arg
                                                      |ARG            |

2345          assert!(c < 4);
              |MACRO()
                     |macro(){
                           |}macro()

2346          assert_eq!(specifier, "./b.js");
              |MACRO()| |macro(){           |}macro()

2347          assert_eq!(referrer, "file:///dyn_import3.js");
              |MACRO()| |macro(){                          |}macro()

2348          let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
              |VAR_DECL
                    |assign                          |apply
                                                      |ARG    |  |ARG   |        |apply

2349          Ok(s)
                |apply
                 |arg

2350        }
            |}func

2351    
2352        fn load(
            |FUNCTION

2353          &self,
              |PARAM

2354          _op_state: Rc<RefCell<OpState>>,
              |PARAM                        |

2355          specifier: &ModuleSpecifier,
              |PARAM                    |

2356          _maybe_referrer: Option<ModuleSpecifier>,
              |PARAM                                 |

2357          _is_dyn_import: bool,
              |PARAM             |

2358        ) -> Pin<Box<ModuleSourceFuture>> {
                                              |func{

2359          self.load_count.fetch_add(1, Ordering::Relaxed);
                                       |apply
                                        |arg
                                           |ARG            |

2360          let info = ModuleSource {
              |VAR_DECL|assign
                         |STRUCT()  |

2361            module_url_specified: specifier.to_string(),
                |ARG                                      |
                                                         |apply

2362            module_url_found: specifier.to_string(),
                |ARG                                  |
                                                     |apply

2363            code: "export function b() { return 'b' }".to_owned(),
                |ARG                                                |
                                                                   |apply

2364          };
2365          async move { Ok(info) }.boxed()
                         |inner{
                             |apply
                              |ARG  |}inner|apply

2366        }
            |}func

2367    
2368        fn prepare_load(
            |FUNCTION

2369          &self,
              |PARAM

2370          _op_state: Rc<RefCell<OpState>>,
              |PARAM                        |

2371          _load_id: ModuleLoadId,
              |PARAM               |

2372          _module_specifier: &ModuleSpecifier,
              |PARAM                            |

2373          _maybe_referrer: Option<String>,
              |PARAM                        |

2374          _is_dyn_import: bool,
              |PARAM             |

2375        ) -> Pin<Box<dyn Future<Output = Result<(), AnyError>>>> {
                                                                     |func{

2376          self.prepare_load_count.fetch_add(1, Ordering::Relaxed);
                                               |apply
                                                |arg
                                                   |ARG            |

2377          async { Ok(()) }.boxed_local()
                    |inner{
                        |apply
                         |ARG
                         |tuple(
                          |)tuple
                             |}inner      |apply

2378        }
            |}func

2379      }
          |}impl

2380    
2381      #[test]
          |OUTER_ATTR

2382      fn dyn_import_ok() {
          |FUNCTION          |func{

2383        run_in_task(|cx| {
                       |apply
                        |ARG |
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{

2384          let loader = Rc::new(DynImportOkLoader::default());
              |VAR_DECL  |assign  |apply
                                   |ARG                       |
                                                             |apply

2385          let prepare_load_count = loader.prepare_load_count.clone();
              |VAR_DECL              |assign                          |apply

2386          let resolve_count = loader.resolve_count.clone();
              |VAR_DECL         |assign                     |apply

2387          let load_count = loader.load_count.clone();
              |VAR_DECL      |assign                  |apply

2388          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG           |
                                               |STRUCT()    |

2389            module_loader: Some(loader),
                |ARG                      |
                                   |apply
                                    |ARG |

2390            ..Default::default()
                                  |apply

2391          });
2392    
2393          // Dynamically import mod_b
2394          runtime
2395            .execute(
                        |apply

2396              "file:///dyn_import3.js",
                  |ARG                   |

2397              r#"
                  |ARG|

2398              (async () => {
2399                let mod = await import("./b.js");
2400                if (mod.b() !== 'b') {
2401                  throw Error("bad1");
2402                }
2403                // And again!
2404                mod = await import("./b.js");
2405                if (mod.b() !== 'b') {
2406                  throw Error("bad2");
2407                }
2408              })();
2409              "#,
2410            )
2411            .unwrap();
                       |apply

2412    
2413          // First poll runs `prepare_load` hook.
2414          assert!(matches!(runtime.poll_event_loop(cx), Poll::Pending));
              |MACRO()
                     |macro(){                                            |}macro()

2415          assert_eq!(prepare_load_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                     |}macro()

2416    
2417          // Second poll actually loads modules into the isolate.
2418          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()

2419          assert_eq!(resolve_count.load(Ordering::Relaxed), 4);
              |MACRO()| |macro(){                                |}macro()

2420          assert_eq!(load_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                             |}macro()

2421          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()

2422          assert_eq!(resolve_count.load(Ordering::Relaxed), 4);
              |MACRO()| |macro(){                                |}macro()

2423          assert_eq!(load_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                             |}macro()

2424        })
            |}inner
            |}closure

2425      }
          |}func

2426    
2427      #[test]
          |OUTER_ATTR

2428      fn dyn_import_borrow_mut_error() {
          |FUNCTION                        |func{

2429        // https://github.com/denoland/deno/issues/6054
2430        run_in_task(|cx| {
                       |apply
                        |ARG |
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{

2431          let loader = Rc::new(DynImportOkLoader::default());
              |VAR_DECL  |assign  |apply
                                   |ARG                       |
                                                             |apply

2432          let prepare_load_count = loader.prepare_load_count.clone();
              |VAR_DECL              |assign                          |apply

2433          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG           |
                                               |STRUCT()    |

2434            module_loader: Some(loader),
                |ARG                      |
                                   |apply
                                    |ARG |

2435            ..Default::default()
                                  |apply

2436          });
2437          runtime
2438            .execute(
                        |apply

2439              "file:///dyn_import3.js",
                  |ARG                   |

2440              r#"
                  |ARG|

2441              (async () => {
2442                let mod = await import("./b.js");
2443                if (mod.b() !== 'b') {
2444                  throw Error("bad");
2445                }
2446                // Now do any op
2447                Deno.core.ops();
2448              })();
2449              "#,
2450            )
2451            .unwrap();
                       |apply

2452          // First poll runs `prepare_load` hook.
2453          let _ = runtime.poll_event_loop(cx);
              |VAR_DECL
                    |assign                  |apply
                                              |ARG

2454          assert_eq!(prepare_load_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                     |}macro()

2455          // Second poll triggers error
2456          let _ = runtime.poll_event_loop(cx);
              |VAR_DECL
                    |assign                  |apply
                                              |ARG

2457        })
            |}inner
            |}closure

2458      }
          |}func

2459    
2460      #[test]
          |OUTER_ATTR

2461      fn es_snapshot() {
          |FUNCTION        |func{

2462        #[derive(Default)]
            |OUTER_ATTR      |

2463        struct ModsLoader;
            |STRUCT

2464    
2465        impl ModuleLoader for ModsLoader {
            |IMPL                            |impl{

2466          fn resolve(
              |FUNCTION

2467            &self,
                |PARAM

2468            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |

2469            specifier: &str,
                |PARAM        |

2470            referrer: &str,
                |PARAM       |

2471            _is_main: bool,
                |PARAM       |

2472          ) -> Result<ModuleSpecifier, AnyError> {
                                                     |func{

2473            assert_eq!(specifier, "file:///main.js");
                |MACRO()| |macro(){                    |}macro()

2474            assert_eq!(referrer, ".");
                |MACRO()| |macro(){     |}macro()

2475            let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
                |VAR_DECL
                      |assign                          |apply
                                                        |ARG    |  |ARG   |        |apply

2476            Ok(s)
                  |apply
                   |arg

2477          }
              |}func

2478    
2479          fn load(
              |FUNCTION

2480            &self,
                |PARAM

2481            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |

2482            _module_specifier: &ModuleSpecifier,
                |PARAM                            |

2483            _maybe_referrer: Option<ModuleSpecifier>,
                |PARAM                                 |

2484            _is_dyn_import: bool,
                |PARAM             |

2485          ) -> Pin<Box<ModuleSourceFuture>> {
                                                |func{

2486            unreachable!()
                |MACRO()  | |macro(){
                             |}macro()

2487          }
              |}func

2488        }
            |}impl

2489    
2490        let loader = std::rc::Rc::new(ModsLoader::default());
            |VAR_DECL  |assign           |apply
                                          |ARG                |
                                                             |apply

2491        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG           |
                                             |STRUCT()    |

2492          module_loader: Some(loader),
              |ARG                      |
                                 |apply
                                  |ARG |

2493          will_snapshot: true,
              |ARG              |

2494          ..Default::default()
                                |apply

2495        });
2496    
2497        let specifier = ModuleSpecifier::resolve_url("file:///main.js").unwrap();
            |VAR_DECL     |assign                       |apply
                                                         |ARG            |        |apply

2498        let source_code = "Deno.core.print('hello\\n')".to_string();
            |VAR_DECL       |assign                                  |apply

2499    
2500        let module_id = futures::executor::block_on(
            |VAR_DECL     |assign                      |apply

2501          runtime.load_module(&specifier, Some(source_code)),
              |ARG                                             |
                                 |apply
                                  |ARG     |  |ARG            |
                                                  |apply
                                                   |ARG      |

2502        )
2503        .unwrap();
                   |apply

2504    
2505        futures::executor::block_on(runtime.mod_evaluate(module_id)).unwrap();
                                       |apply
                                        |ARG                          |
                                                            |apply
                                                             |ARG    |         |apply

2506    
2507        let _snapshot = runtime.snapshot();
            |VAR_DECL     |assign           |apply

2508      }
          |}func

2509    
2510      #[test]
          |OUTER_ATTR

2511      fn test_error_without_stack() {
          |FUNCTION                     |func{

2512        let mut runtime = JsRuntime::new(RuntimeOptions::default());
            |VAR_DECL       |assign         |apply
                                             |ARG                    |
                                                                    |apply

2513        // SyntaxError
2514        let result = runtime.execute(
            |VAR_DECL  |assign          |apply

2515          "error_without_stack.js",
              |ARG                   |

2516          r#"
              |ARG|

2517    function main() {
2518      console.log("asdf);
2519    }
2520    main();
2521    "#,
2522        );
2523        let expected_error = r#"Uncaught SyntaxError: Invalid or unexpected token
            |VAR_DECL          |assign

2524        at error_without_stack.js:3:14"#;
2525        assert_eq!(result.unwrap_err().to_string(), expected_error);
            |MACRO()| |macro(){                                       |}macro()

2526      }
          |}func

2527    
2528      #[test]
          |OUTER_ATTR

2529      fn test_error_stack() {
          |FUNCTION             |func{

2530        let mut runtime = JsRuntime::new(RuntimeOptions::default());
            |VAR_DECL       |assign         |apply
                                             |ARG                    |
                                                                    |apply

2531        let result = runtime.execute(
            |VAR_DECL  |assign          |apply

2532          "error_stack.js",
              |ARG           |

2533          r#"
              |ARG|

2534    function assert(cond) {
2535      if (!cond) {
2536        throw Error("assert");
2537      }
2538    }
2539    function main() {
2540      assert(false);
2541    }
2542    main();
2543            "#,
2544        );
2545        let expected_error = r#"Error: assert
            |VAR_DECL          |assign

2546        at assert (error_stack.js:4:11)
2547        at main (error_stack.js:9:3)
2548        at error_stack.js:12:1"#;
2549        assert_eq!(result.unwrap_err().to_string(), expected_error);
            |MACRO()| |macro(){                                       |}macro()

2550      }
          |}func

2551    
2552      #[test]
          |OUTER_ATTR

2553      fn test_error_async_stack() {
          |FUNCTION                   |func{

2554        run_in_task(|cx| {
                       |apply
                        |ARG |
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{

2555          let mut runtime = JsRuntime::new(RuntimeOptions::default());
              |VAR_DECL       |assign         |apply
                                               |ARG                    |
                                                                      |apply

2556          runtime
2557            .execute(
                        |apply

2558              "error_async_stack.js",
                  |ARG                 |

2559              r#"
                  |ARG|

2560    (async () => {
2561      const p = (async () => {
2562        await Promise.resolve().then(() => {
2563          throw new Error("async");
2564        });
2565      })();
2566      try {
2567        await p;
2568      } catch (error) {
2569        console.log(error.stack);
2570        throw error;
2571      }
2572    })();"#,
2573            )
2574            .unwrap();
                       |apply

2575          let expected_error = r#"Error: async
              |VAR_DECL          |assign

2576        at error_async_stack.js:5:13
2577        at async error_async_stack.js:4:5
2578        at async error_async_stack.js:10:5"#;
2579    
2580          match runtime.poll_event_loop(cx) {
              |MATCH                       |apply
                                            |ARG|match{

2581            Poll::Ready(Err(e)) => {
                |CASE
                |STRUCT()   |ARG |
                            |STRUCT()
                                |arg   |inner{

2582              assert_eq!(e.to_string(), expected_error);
                  |MACRO()| |macro(){                     |}macro()

2583            }
                |}inner

2584            _ => panic!(),
                |case|MACRO()
                           |macro(){
                            |}macro()

2585          };
              |}match

2586        })
            |}inner
            |}closure

2587      }
          |}func

2588    
2589      #[test]
          |OUTER_ATTR

2590      fn test_core_js_stack_frame() {
          |FUNCTION                     |func{

2591        let mut runtime = JsRuntime::new(RuntimeOptions::default());
            |VAR_DECL       |assign         |apply
                                             |ARG                    |
                                                                    |apply

2592        // Call non-existent op so we get error from `core.js`
2593        let error = runtime
            |VAR_DECL |assign

2594          .execute(
                      |apply

2595            "core_js_stack_frame.js",
                |ARG                   |

2596            "Deno.core.dispatchByName('non_existent');",
                |ARG                                      |

2597          )
2598          .unwrap_err();
                         |apply

2599        let error_string = error.to_string();
            |VAR_DECL        |assign          |apply

2600        // Test that the script specifier is a URL: `deno:<repo-relative path>`.
2601        assert!(error_string.contains("deno:core/core.js"));
            |MACRO()
                   |macro(){                                  |}macro()

2602      }
          |}func

2603    }
        |}module
        |<eof>

